{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"2255b766-425b-47a6-b780-120c73f875bb","timestamp":"2025-08-11T05:23:31.478Z"}
{"parentUuid":"2255b766-425b-47a6-b780-120c73f875bb","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n          <command-message>clear</command-message>\n          <command-args></command-args>"},"uuid":"9628e628-eefe-44d5-acdc-d9a0605e0ece","timestamp":"2025-08-11T05:23:31.469Z"}
{"parentUuid":"9628e628-eefe-44d5-acdc-d9a0605e0ece","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"166e738c-3cea-4dfd-be85-ee9fb3e8f6a2","timestamp":"2025-08-11T05:23:31.477Z"}
{"parentUuid":"166e738c-3cea-4dfd-be85-ee9fb3e8f6a2","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":"@tasks/phase-6-sprite-component.md file has some sections that are not properly formatted. Can you fix that for us?"},"uuid":"597320bd-06ec-468e-a06b-a9250913eb6e","timestamp":"2025-08-11T05:23:58.119Z"}
{"parentUuid":"597320bd-06ec-468e-a06b-a9250913eb6e","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_015VtZqAYFyDupc96mz2r2UX","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I'll analyze the `@tasks/phase-6-sprite-component.md` file to identify and fix formatting issues.\n\nLooking at the file, I can see several formatting problems:\n\n1. **Line 262-end**: There are escaped newlines (`\\\\n`) instead of actual line breaks, making the code blocks unreadable\n2. The C code implementation section is completely malformed with escaped characters\n3. Missing proper code block formatting in several places\n\nLet me create a plan to fix these formatting issues:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":18557,"cache_read_input_tokens":17437,"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CS1N65qJgsZ1erGxwrdaa","type":"assistant","uuid":"82142747-b783-4b0d-8282-8010eef016ec","timestamp":"2025-08-11T05:24:05.885Z"}
{"parentUuid":"82142747-b783-4b0d-8282-8010eef016ec","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_015VtZqAYFyDupc96mz2r2UX","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_017cGVoxr2RWAoz1ZtgXGUgy","name":"ExitPlanMode","input":{"plan":"## Plan to Fix Formatting Issues in phase-6-sprite-component.md\n\n### Issues Identified:\n1. **Escaped newlines**: Lines 262+ have `\\\\n` instead of actual line breaks\n2. **Malformed code blocks**: C implementation sections are unreadable due to escape characters\n3. **Missing code block formatting**: Some sections lack proper markdown code blocks\n\n### Fixes to Apply:\n1. **Replace escaped newlines**: Convert all `\\\\n` sequences to actual line breaks\n2. **Fix C code formatting**: Restore proper indentation and structure to all C code blocks\n3. **Ensure proper markdown**: Verify all code blocks have correct triple-backtick formatting\n4. **Maintain content integrity**: Preserve all technical content while fixing only formatting\n\n### Scope:\n- Fix formatting issues from line 262 onwards\n- Focus on the sprite_component.c implementation section\n- Ensure all code remains functionally identical\n- Maintain proper markdown structure throughout\n\nThis will make the technical documentation readable while preserving all the detailed implementation specifications."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":18557,"cache_read_input_tokens":17437,"output_tokens":397,"service_tier":"standard"}},"requestId":"req_011CS1N65qJgsZ1erGxwrdaa","type":"assistant","uuid":"b4a06512-e7e1-47cf-83ea-d8a3d6df9b5f","timestamp":"2025-08-11T05:24:10.942Z"}
{"parentUuid":"b4a06512-e7e1-47cf-83ea-d8a3d6df9b5f","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has approved your plan. You can now start coding. Start with updating your todo list if applicable","tool_use_id":"toolu_017cGVoxr2RWAoz1ZtgXGUgy"}]},"uuid":"5385aca7-8205-4d0e-8da9-97ff1506eb3f","timestamp":"2025-08-11T05:24:58.113Z","toolUseResult":{"plan":"## Plan to Fix Formatting Issues in phase-6-sprite-component.md\n\n### Issues Identified:\n1. **Escaped newlines**: Lines 262+ have `\\\\n` instead of actual line breaks\n2. **Malformed code blocks**: C implementation sections are unreadable due to escape characters\n3. **Missing code block formatting**: Some sections lack proper markdown code blocks\n\n### Fixes to Apply:\n1. **Replace escaped newlines**: Convert all `\\\\n` sequences to actual line breaks\n2. **Fix C code formatting**: Restore proper indentation and structure to all C code blocks\n3. **Ensure proper markdown**: Verify all code blocks have correct triple-backtick formatting\n4. **Maintain content integrity**: Preserve all technical content while fixing only formatting\n\n### Scope:\n- Fix formatting issues from line 262 onwards\n- Focus on the sprite_component.c implementation section\n- Ensure all code remains functionally identical\n- Maintain proper markdown structure throughout\n\nThis will make the technical documentation readable while preserving all the detailed implementation specifications.","isAgent":false}}
{"parentUuid":"5385aca7-8205-4d0e-8da9-97ff1506eb3f","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01ET5YSER2SRUH7rDLteobiU","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01SnAZvzMcVpCuz6oo5qifHJ","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Fix escaped newlines and malformed code blocks in sprite component documentation","status":"in_progress"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":426,"cache_read_input_tokens":35994,"output_tokens":98,"service_tier":"standard"}},"requestId":"req_011CS1NAWUzFFxygMgX9NSFc","type":"assistant","uuid":"971fa6ea-1b64-4928-9ee9-adad0de83112","timestamp":"2025-08-11T05:25:01.572Z"}
{"parentUuid":"971fa6ea-1b64-4928-9ee9-adad0de83112","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SnAZvzMcVpCuz6oo5qifHJ","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"83a423eb-cbd7-4fff-9846-bbf5d625c45b","timestamp":"2025-08-11T05:25:01.619Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Fix escaped newlines and malformed code blocks in sprite component documentation","status":"in_progress","id":"1"}]}}
{"parentUuid":"83a423eb-cbd7-4fff-9846-bbf5d625c45b","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01Rtquun9Rr7PSbm4RAAqeXX","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01AsdegCLopFT3F8xJEkr3Qb","name":"Edit","input":{"file_path":"/Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md","old_string":"static void sprite_component_init(Component* component, GameObject* gameObject) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Initialize sprite properties\n    sprite->bitmap = NULL;\\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\\n    sprite->anchorX = 0.5f;\\n    sprite->anchorY = 0.5f;\\n    sprite->flip = kBitmapUnflipped;\\n    sprite->opacity = 1.0f;\\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\\n    \\n    // Initialize cached transform\\n    sprite->renderX = 0.0f;\\n    sprite->renderY = 0.0f;\\n    sprite->renderWidth = 0.0f;\\n    sprite->renderHeight = 0.0f;\\n    sprite->transformDirty = true;\\n    \\n    // Initialize animation\\n    sprite->animation = NULL;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = false;\\n    sprite->animationLooping = false;\\n    \\n    // Initialize atlas\\n    sprite->atlas = NULL;\\n    sprite->atlasIndex = 0;\\n    \\n    // Initialize rendering\\n    sprite->visible = true;\\n    sprite->culled = false;\\n    sprite->renderLayer = 0;\\n    sprite->sortingOrder = 0;\\n    \\n    // Initialize color\\n    sprite->colorR = 255;\\n    sprite->colorG = 255;\\n    sprite->colorB = 255;\\n}\\n\\nstatic void sprite_component_destroy_impl(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    // Note: We don't free the bitmap here as it may be shared\\n    // Bitmap management should be handled by asset management system\\n    sprite->bitmap = NULL;\\n    sprite->animation = NULL;\\n    sprite->atlas = NULL;\\n}\\n\\nstatic void sprite_component_update(Component* component, float deltaTime) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite->visible) {\\n        return;\\n    }\\n    \\n    // Update animation\\n    if (sprite->animationPlaying && sprite->animation) {\\n        sprite->animationTime += deltaTime;\\n        \\n        // Check if animation finished\\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\\n            if (sprite->animationLooping || sprite->animation->looping) {\\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\\n            } else {\\n                sprite->animationTime = sprite->animation->totalDuration;\\n                sprite->animationPlaying = false;\\n                \\n                // Play next animation if specified\\n                if (sprite->animation->nextAnimation) {\\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\\n                }\\n            }\\n        }\\n        \\n        // Update current frame\\n        sprite_component_update_animation_frame(sprite);\\n    }\\n    \\n    // Update transform cache if dirty\\n    if (sprite->transformDirty) {\\n        sprite_component_update_transform_cache(sprite);\\n    }\\n}\\n\\nstatic void sprite_component_render(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite_component_needs_render(sprite) || !g_pd) {\\n        return;\\n    }\\n    \\n    // Set rendering properties\\n    if (sprite->opacity < 1.0f) {\\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\\n        // Implementation depends on Playdate's capabilities\\n    }\\n    \\n    // Calculate render position with anchor\\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\\n    \\n    // Render sprite\\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\\n        // Render with source rectangle (sprite sheet)\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    } else {\\n        // Render full bitmap\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    }\\n}\\n\\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\\n    if (!sprite) {\\n        return false;\\n    }\\n    \\n    sprite->bitmap = bitmap;\\n    \\n    if (bitmap && g_pd) {\\n        // Update source rectangle to match bitmap size if not set\\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\\n            int width, height;\\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\\n        }\\n        \\n        sprite_component_mark_transform_dirty(sprite);\\n    }\\n    \\n    return true;\\n}\\n\\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\\n    if (!sprite || !path || !g_pd) {\\n        return false;\\n    }\\n    \\n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\\n    if (!bitmap) {\\n        return false;\\n    }\\n    \\n    return sprite_component_set_bitmap(sprite, bitmap);\\n}\\n\\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\\n    if (!sprite) return;\\n    \\n    sprite->sourceRect = (LCDRect){x, y, width, height};\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\\n    if (!sprite) return;\\n    \\n    sprite->anchorX = anchorX;\\n    sprite->anchorY = anchorY;\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\\n    if (!sprite || !animation) {\\n        return false;\\n    }\\n    \\n    sprite->animation = animation;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = true;\\n    sprite->animationLooping = animation->looping;\\n    \\n    // Set first frame\\n    if (animation->frameCount > 0) {\\n        SpriteFrame* frame = &animation->frames[0];\\n        sprite_component_set_source_rect(sprite, \\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n    \\n    return true;\\n}\\n\\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\\n    if (sprite) {\\n        sprite->visible = visible;\\n    }\\n}\\n\\n// Helper function to update animation frame\\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\\n        return;\\n    }\\n    \\n    // Find current frame based on time\\n    float accumulatedTime = 0.0f;\\n    uint32_t frameIndex = 0;\\n    \\n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\\n        accumulatedTime += sprite->animation->frames[i].duration;\\n        if (sprite->animationTime < accumulatedTime) {\\n            frameIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    // Update frame if changed\\n    if (frameIndex != sprite->currentFrame) {\\n        sprite->currentFrame = frameIndex;\\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\\n        \\n        sprite_component_set_source_rect(sprite,\\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n}\\n\\n// Helper function to update transform cache\\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\\n        return;\\n    }\\n    \\n    TransformComponent* transform = sprite->base.gameObject->transform;\\n    \\n    // Get world position\\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\\n    \\n    // Get render size\\n    sprite->renderWidth = (float)sprite->sourceRect.width;\\n    sprite->renderHeight = (float)sprite->sourceRect.height;\\n    \\n    // Apply transform scale\\n    float scaleX, scaleY;\\n    transform_component_get_scale(transform, &scaleX, &scaleY);\\n    sprite->renderWidth *= scaleX;\\n    sprite->renderHeight *= scaleY;\\n    \\n    sprite->transformDirty = false;\\n}","new_string":"static void sprite_component_init(Component* component, GameObject* gameObject) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Initialize sprite properties\n    sprite->bitmap = NULL;\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\n    sprite->anchorX = 0.5f;\n    sprite->anchorY = 0.5f;\n    sprite->flip = kBitmapUnflipped;\n    sprite->opacity = 1.0f;\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\n    \n    // Initialize cached transform\n    sprite->renderX = 0.0f;\n    sprite->renderY = 0.0f;\n    sprite->renderWidth = 0.0f;\n    sprite->renderHeight = 0.0f;\n    sprite->transformDirty = true;\n    \n    // Initialize animation\n    sprite->animation = NULL;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = false;\n    sprite->animationLooping = false;\n    \n    // Initialize atlas\n    sprite->atlas = NULL;\n    sprite->atlasIndex = 0;\n    \n    // Initialize rendering\n    sprite->visible = true;\n    sprite->culled = false;\n    sprite->renderLayer = 0;\n    sprite->sortingOrder = 0;\n    \n    // Initialize color\n    sprite->colorR = 255;\n    sprite->colorG = 255;\n    sprite->colorB = 255;\n}\n\nstatic void sprite_component_destroy_impl(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Note: We don't free the bitmap here as it may be shared\n    // Bitmap management should be handled by asset management system\n    sprite->bitmap = NULL;\n    sprite->animation = NULL;\n    sprite->atlas = NULL;\n}\n\nstatic void sprite_component_update(Component* component, float deltaTime) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite->visible) {\n        return;\n    }\n    \n    // Update animation\n    if (sprite->animationPlaying && sprite->animation) {\n        sprite->animationTime += deltaTime;\n        \n        // Check if animation finished\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\n            if (sprite->animationLooping || sprite->animation->looping) {\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\n            } else {\n                sprite->animationTime = sprite->animation->totalDuration;\n                sprite->animationPlaying = false;\n                \n                // Play next animation if specified\n                if (sprite->animation->nextAnimation) {\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\n                }\n            }\n        }\n        \n        // Update current frame\n        sprite_component_update_animation_frame(sprite);\n    }\n    \n    // Update transform cache if dirty\n    if (sprite->transformDirty) {\n        sprite_component_update_transform_cache(sprite);\n    }\n}\n\nstatic void sprite_component_render(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite_component_needs_render(sprite) || !g_pd) {\n        return;\n    }\n    \n    // Set rendering properties\n    if (sprite->opacity < 1.0f) {\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\n        // Implementation depends on Playdate's capabilities\n    }\n    \n    // Calculate render position with anchor\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\n    \n    // Render sprite\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\n        // Render with source rectangle (sprite sheet)\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    } else {\n        // Render full bitmap\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    }\n}\n\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\n    if (!sprite) {\n        return false;\n    }\n    \n    sprite->bitmap = bitmap;\n    \n    if (bitmap && g_pd) {\n        // Update source rectangle to match bitmap size if not set\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\n            int width, height;\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\n        }\n        \n        sprite_component_mark_transform_dirty(sprite);\n    }\n    \n    return true;\n}\n\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\n    if (!sprite || !path || !g_pd) {\n        return false;\n    }\n    \n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\n    if (!bitmap) {\n        return false;\n    }\n    \n    return sprite_component_set_bitmap(sprite, bitmap);\n}\n\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\n    if (!sprite) return;\n    \n    sprite->sourceRect = (LCDRect){x, y, width, height};\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\n    if (!sprite) return;\n    \n    sprite->anchorX = anchorX;\n    sprite->anchorY = anchorY;\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\n    if (!sprite || !animation) {\n        return false;\n    }\n    \n    sprite->animation = animation;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = true;\n    sprite->animationLooping = animation->looping;\n    \n    // Set first frame\n    if (animation->frameCount > 0) {\n        SpriteFrame* frame = &animation->frames[0];\n        sprite_component_set_source_rect(sprite, \n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n    \n    return true;\n}\n\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\n    if (sprite) {\n        sprite->visible = visible;\n    }\n}\n\n// Helper function to update animation frame\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\n        return;\n    }\n    \n    // Find current frame based on time\n    float accumulatedTime = 0.0f;\n    uint32_t frameIndex = 0;\n    \n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\n        accumulatedTime += sprite->animation->frames[i].duration;\n        if (sprite->animationTime < accumulatedTime) {\n            frameIndex = i;\n            break;\n        }\n    }\n    \n    // Update frame if changed\n    if (frameIndex != sprite->currentFrame) {\n        sprite->currentFrame = frameIndex;\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\n        \n        sprite_component_set_source_rect(sprite,\n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n}\n\n// Helper function to update transform cache\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\n        return;\n    }\n    \n    TransformComponent* transform = sprite->base.gameObject->transform;\n    \n    // Get world position\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\n    \n    // Get render size\n    sprite->renderWidth = (float)sprite->sourceRect.width;\n    sprite->renderHeight = (float)sprite->sourceRect.height;\n    \n    // Apply transform scale\n    float scaleX, scaleY;\n    transform_component_get_scale(transform, &scaleX, &scaleY);\n    sprite->renderWidth *= scaleX;\n    sprite->renderHeight *= scaleY;\n    \n    sprite->transformDirty = false;\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":127,"cache_read_input_tokens":36420,"output_tokens":5021,"service_tier":"standard"}},"requestId":"req_011CS1NAmGEscAiQDep3wk3W","type":"assistant","uuid":"921e6146-3868-4367-8caf-846aa6b97a50","timestamp":"2025-08-11T05:25:53.212Z"}
{"parentUuid":"921e6146-3868-4367-8caf-846aa6b97a50","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AsdegCLopFT3F8xJEkr3Qb","type":"tool_result","content":"The file /Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   254→    Component* baseComponent = component_registry_create(COMPONENT_TYPE_SPRITE, gameObject);\n   255→    return (SpriteComponent*)baseComponent;\n   256→}\n   257→\n   258→static void sprite_component_init(Component* component, GameObject* gameObject) {\n   259→    SpriteComponent* sprite = (SpriteComponent*)component;\n   260→    \n   261→    // Initialize sprite properties\n   262→    sprite->bitmap = NULL;\n   263→    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\n   264→    sprite->anchorX = 0.5f;\n   265→    sprite->anchorY = 0.5f;\n   266→    sprite->flip = kBitmapUnflipped;\n   267→    sprite->opacity = 1.0f;\n   268→    sprite->renderMode = SPRITE_RENDER_NORMAL;\n   269→    \n   270→    // Initialize cached transform\n   271→    sprite->renderX = 0.0f;\n   272→    sprite->renderY = 0.0f;\n   273→    sprite->renderWidth = 0.0f;\n   274→    sprite->renderHeight = 0.0f;\n   275→    sprite->transformDirty = true;\n   276→    \n   277→    // Initialize animation\n   278→    sprite->animation = NULL;\n   279→    sprite->animationTime = 0.0f;\n   280→    sprite->currentFrame = 0;\n   281→    sprite->animationPlaying = false;\n   282→    sprite->animationLooping = false;\n   283→    \n   284→    // Initialize atlas\n   285→    sprite->atlas = NULL;\n   286→    sprite->atlasIndex = 0;\n   287→    \n   288→    // Initialize rendering\n   289→    sprite->visible = true;\n   290→    sprite->culled = false;\n   291→    sprite->renderLayer = 0;\n   292→    sprite->sortingOrder = 0;\n   293→    \n   294→    // Initialize color\n   295→    sprite->colorR = 255;\n   296→    sprite->colorG = 255;\n   297→    sprite->colorB = 255;\n   298→}\n   299→\n   300→static void sprite_component_destroy_impl(Component* component) {\n   301→    SpriteComponent* sprite = (SpriteComponent*)component;\n   302→    \n   303→    // Note: We don't free the bitmap here as it may be shared\n   304→    // Bitmap management should be handled by asset management system\n   305→    sprite->bitmap = NULL;\n   306→    sprite->animation = NULL;\n   307→    sprite->atlas = NULL;\n   308→}\n   309→\n   310→static void sprite_component_update(Component* component, float deltaTime) {\n   311→    SpriteComponent* sprite = (SpriteComponent*)component;\n   312→    \n   313→    if (!sprite->visible) {\n   314→        return;\n   315→    }\n   316→    \n   317→    // Update animation\n   318→    if (sprite->animationPlaying && sprite->animation) {\n   319→        sprite->animationTime += deltaTime;\n   320→        \n   321→        // Check if animation finished\n   322→        if (sprite->animationTime >= sprite->animation->totalDuration) {\n   323→            if (sprite->animationLooping || sprite->animation->looping) {\n   324→                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\n   325→            } else {\n   326→                sprite->animationTime = sprite->animation->totalDuration;\n   327→                sprite->animationPlaying = false;\n   328→                \n   329→                // Play next animation if specified\n   330→                if (sprite->animation->nextAnimation) {\n   331→                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\n   332→                }\n   333→            }\n   334→        }\n   335→        \n   336→        // Update current frame\n   337→        sprite_component_update_animation_frame(sprite);\n   338→    }\n   339→    \n   340→    // Update transform cache if dirty\n   341→    if (sprite->transformDirty) {\n   342→        sprite_component_update_transform_cache(sprite);\n   343→    }\n   344→}\n   345→\n   346→static void sprite_component_render(Component* component) {\n   347→    SpriteComponent* sprite = (SpriteComponent*)component;\n   348→    \n   349→    if (!sprite_component_needs_render(sprite) || !g_pd) {\n   350→        return;\n   351→    }\n   352→    \n   353→    // Set rendering properties\n   354→    if (sprite->opacity < 1.0f) {\n   355→        // Handle transparency (Playdate is 1-bit, so this might be dithering)\n   356→        // Implementation depends on Playdate's capabilities\n   357→    }\n   358→    \n   359→    // Calculate render position with anchor\n   360→    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\n   361→    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\n   362→    \n   363→    // Render sprite\n   364→    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\n   365→        // Render with source rectangle (sprite sheet)\n   366→        g_pd->graphics->drawBitmap(sprite->bitmap, \n   367→                                 (int)renderX, (int)renderY, \n   368→                                 sprite->flip);\n   369→    } else {\n   370→        // Render full bitmap\n   371→        g_pd->graphics->drawBitmap(sprite->bitmap, \n   372→                                 (int)renderX, (int)renderY, \n   373→                                 sprite->flip);\n   374→    }\n   375→}\n   376→\n   377→bool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\n   378→    if (!sprite) {\n   379→        return false;\n   380→    }\n   381→    \n   382→    sprite->bitmap = bitmap;\n   383→    \n   384→    if (bitmap && g_pd) {\n   385→        // Update source rectangle to match bitmap size if not set\n   386→        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\n   387→            int width, height;\n   388→            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\n   389→            sprite->sourceRect = (LCDRect){0, 0, width, height};\n   390→        }\n   391→        \n   392→        sprite_component_mark_transform_dirty(sprite);\n   393→    }\n   394→    \n   395→    return true;\n   396→}\n   397→\n   398→bool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\n   399→    if (!sprite || !path || !g_pd) {\n   400→        return false;\n   401→    }\n   402→    \n   403→    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\n   404→    if (!bitmap) {\n   405→        return false;\n   406→    }\n   407→    \n   408→    return sprite_component_set_bitmap(sprite, bitmap);\n   409→}\n   410→\n   411→void sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\n   412→    if (!sprite) return;\n   413→    \n   414→    sprite->sourceRect = (LCDRect){x, y, width, height};\n   415→    sprite_component_mark_transform_dirty(sprite);\n   416→}\n   417→\n   418→void sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\n   419→    if (!sprite) return;\n   420→    \n   421→    sprite->anchorX = anchorX;\n   422→    sprite->anchorY = anchorY;\n   423→    sprite_component_mark_transform_dirty(sprite);\n   424→}\n   425→\n   426→bool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\n   427→    if (!sprite || !animation) {\n   428→        return false;\n   429→    }\n   430→    \n   431→    sprite->animation = animation;\n   432→    sprite->animationTime = 0.0f;\n   433→    sprite->currentFrame = 0;\n   434→    sprite->animationPlaying = true;\n   435→    sprite->animationLooping = animation->looping;\n   436→    \n   437→    // Set first frame\n   438→    if (animation->frameCount > 0) {\n   439→        SpriteFrame* frame = &animation->frames[0];\n   440→        sprite_component_set_source_rect(sprite, \n   441→                                        frame->sourceRect.x, frame->sourceRect.y,\n   442→                                        frame->sourceRect.width, frame->sourceRect.height);\n   443→        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n   444→    }\n   445→    \n   446→    return true;\n   447→}\n   448→\n   449→void sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\n   450→    if (sprite) {\n   451→        sprite->visible = visible;\n   452→    }\n   453→}\n   454→\n   455→// Helper function to update animation frame\n   456→static void sprite_component_update_animation_frame(SpriteComponent* sprite) {\n   457→    if (!sprite->animation || sprite->animation->frameCount == 0) {\n   458→        return;\n   459→    }\n   460→    \n   461→    // Find current frame based on time\n   462→    float accumulatedTime = 0.0f;\n   463→    uint32_t frameIndex = 0;\n   464→    \n   465→    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\n   466→        accumulatedTime += sprite->animation->frames[i].duration;\n   467→        if (sprite->animationTime < accumulatedTime) {\n   468→            frameIndex = i;\n   469→            break;\n   470→        }\n   471→    }\n   472→    \n   473→    // Update frame if changed\n   474→    if (frameIndex != sprite->currentFrame) {\n   475→        sprite->currentFrame = frameIndex;\n   476→        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\n   477→        \n   478→        sprite_component_set_source_rect(sprite,\n   479→                                        frame->sourceRect.x, frame->sourceRect.y,\n   480→                                        frame->sourceRect.width, frame->sourceRect.height);\n   481→        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n   482→    }\n   483→}\n   484→\n   485→// Helper function to update transform cache\n   486→static void sprite_component_update_transform_cache(SpriteComponent* sprite) {\n   487→    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\n   488→        return;\n   489→    }\n   490→    \n   491→    TransformComponent* transform = sprite->base.gameObject->transform;\n   492→    \n   493→    // Get world position\n   494→    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\n   495→    \n   496→    // Get render size\n   497→    sprite->renderWidth = (float)sprite->sourceRect.width;\n   498→    sprite->renderHeight = (float)sprite->sourceRect.height;\n   499→    \n   500→    // Apply transform scale\n   501→    float scaleX, scaleY;\n   502→    transform_component_get_scale(transform, &scaleX, &scaleY);\n   503→    sprite->renderWidth *= scaleX;\n   504→    sprite->renderHeight *= scaleY;\n   505→    \n   506→    sprite->transformDirty = false;\n   507→}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform."}]},"uuid":"bb4bab03-0743-4e59-bf12-446ebdd1271b","timestamp":"2025-08-11T05:25:53.241Z","toolUseResult":{"filePath":"/Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md","oldString":"static void sprite_component_init(Component* component, GameObject* gameObject) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Initialize sprite properties\n    sprite->bitmap = NULL;\\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\\n    sprite->anchorX = 0.5f;\\n    sprite->anchorY = 0.5f;\\n    sprite->flip = kBitmapUnflipped;\\n    sprite->opacity = 1.0f;\\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\\n    \\n    // Initialize cached transform\\n    sprite->renderX = 0.0f;\\n    sprite->renderY = 0.0f;\\n    sprite->renderWidth = 0.0f;\\n    sprite->renderHeight = 0.0f;\\n    sprite->transformDirty = true;\\n    \\n    // Initialize animation\\n    sprite->animation = NULL;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = false;\\n    sprite->animationLooping = false;\\n    \\n    // Initialize atlas\\n    sprite->atlas = NULL;\\n    sprite->atlasIndex = 0;\\n    \\n    // Initialize rendering\\n    sprite->visible = true;\\n    sprite->culled = false;\\n    sprite->renderLayer = 0;\\n    sprite->sortingOrder = 0;\\n    \\n    // Initialize color\\n    sprite->colorR = 255;\\n    sprite->colorG = 255;\\n    sprite->colorB = 255;\\n}\\n\\nstatic void sprite_component_destroy_impl(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    // Note: We don't free the bitmap here as it may be shared\\n    // Bitmap management should be handled by asset management system\\n    sprite->bitmap = NULL;\\n    sprite->animation = NULL;\\n    sprite->atlas = NULL;\\n}\\n\\nstatic void sprite_component_update(Component* component, float deltaTime) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite->visible) {\\n        return;\\n    }\\n    \\n    // Update animation\\n    if (sprite->animationPlaying && sprite->animation) {\\n        sprite->animationTime += deltaTime;\\n        \\n        // Check if animation finished\\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\\n            if (sprite->animationLooping || sprite->animation->looping) {\\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\\n            } else {\\n                sprite->animationTime = sprite->animation->totalDuration;\\n                sprite->animationPlaying = false;\\n                \\n                // Play next animation if specified\\n                if (sprite->animation->nextAnimation) {\\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\\n                }\\n            }\\n        }\\n        \\n        // Update current frame\\n        sprite_component_update_animation_frame(sprite);\\n    }\\n    \\n    // Update transform cache if dirty\\n    if (sprite->transformDirty) {\\n        sprite_component_update_transform_cache(sprite);\\n    }\\n}\\n\\nstatic void sprite_component_render(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite_component_needs_render(sprite) || !g_pd) {\\n        return;\\n    }\\n    \\n    // Set rendering properties\\n    if (sprite->opacity < 1.0f) {\\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\\n        // Implementation depends on Playdate's capabilities\\n    }\\n    \\n    // Calculate render position with anchor\\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\\n    \\n    // Render sprite\\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\\n        // Render with source rectangle (sprite sheet)\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    } else {\\n        // Render full bitmap\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    }\\n}\\n\\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\\n    if (!sprite) {\\n        return false;\\n    }\\n    \\n    sprite->bitmap = bitmap;\\n    \\n    if (bitmap && g_pd) {\\n        // Update source rectangle to match bitmap size if not set\\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\\n            int width, height;\\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\\n        }\\n        \\n        sprite_component_mark_transform_dirty(sprite);\\n    }\\n    \\n    return true;\\n}\\n\\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\\n    if (!sprite || !path || !g_pd) {\\n        return false;\\n    }\\n    \\n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\\n    if (!bitmap) {\\n        return false;\\n    }\\n    \\n    return sprite_component_set_bitmap(sprite, bitmap);\\n}\\n\\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\\n    if (!sprite) return;\\n    \\n    sprite->sourceRect = (LCDRect){x, y, width, height};\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\\n    if (!sprite) return;\\n    \\n    sprite->anchorX = anchorX;\\n    sprite->anchorY = anchorY;\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\\n    if (!sprite || !animation) {\\n        return false;\\n    }\\n    \\n    sprite->animation = animation;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = true;\\n    sprite->animationLooping = animation->looping;\\n    \\n    // Set first frame\\n    if (animation->frameCount > 0) {\\n        SpriteFrame* frame = &animation->frames[0];\\n        sprite_component_set_source_rect(sprite, \\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n    \\n    return true;\\n}\\n\\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\\n    if (sprite) {\\n        sprite->visible = visible;\\n    }\\n}\\n\\n// Helper function to update animation frame\\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\\n        return;\\n    }\\n    \\n    // Find current frame based on time\\n    float accumulatedTime = 0.0f;\\n    uint32_t frameIndex = 0;\\n    \\n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\\n        accumulatedTime += sprite->animation->frames[i].duration;\\n        if (sprite->animationTime < accumulatedTime) {\\n            frameIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    // Update frame if changed\\n    if (frameIndex != sprite->currentFrame) {\\n        sprite->currentFrame = frameIndex;\\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\\n        \\n        sprite_component_set_source_rect(sprite,\\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n}\\n\\n// Helper function to update transform cache\\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\\n        return;\\n    }\\n    \\n    TransformComponent* transform = sprite->base.gameObject->transform;\\n    \\n    // Get world position\\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\\n    \\n    // Get render size\\n    sprite->renderWidth = (float)sprite->sourceRect.width;\\n    sprite->renderHeight = (float)sprite->sourceRect.height;\\n    \\n    // Apply transform scale\\n    float scaleX, scaleY;\\n    transform_component_get_scale(transform, &scaleX, &scaleY);\\n    sprite->renderWidth *= scaleX;\\n    sprite->renderHeight *= scaleY;\\n    \\n    sprite->transformDirty = false;\\n}","newString":"static void sprite_component_init(Component* component, GameObject* gameObject) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Initialize sprite properties\n    sprite->bitmap = NULL;\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\n    sprite->anchorX = 0.5f;\n    sprite->anchorY = 0.5f;\n    sprite->flip = kBitmapUnflipped;\n    sprite->opacity = 1.0f;\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\n    \n    // Initialize cached transform\n    sprite->renderX = 0.0f;\n    sprite->renderY = 0.0f;\n    sprite->renderWidth = 0.0f;\n    sprite->renderHeight = 0.0f;\n    sprite->transformDirty = true;\n    \n    // Initialize animation\n    sprite->animation = NULL;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = false;\n    sprite->animationLooping = false;\n    \n    // Initialize atlas\n    sprite->atlas = NULL;\n    sprite->atlasIndex = 0;\n    \n    // Initialize rendering\n    sprite->visible = true;\n    sprite->culled = false;\n    sprite->renderLayer = 0;\n    sprite->sortingOrder = 0;\n    \n    // Initialize color\n    sprite->colorR = 255;\n    sprite->colorG = 255;\n    sprite->colorB = 255;\n}\n\nstatic void sprite_component_destroy_impl(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Note: We don't free the bitmap here as it may be shared\n    // Bitmap management should be handled by asset management system\n    sprite->bitmap = NULL;\n    sprite->animation = NULL;\n    sprite->atlas = NULL;\n}\n\nstatic void sprite_component_update(Component* component, float deltaTime) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite->visible) {\n        return;\n    }\n    \n    // Update animation\n    if (sprite->animationPlaying && sprite->animation) {\n        sprite->animationTime += deltaTime;\n        \n        // Check if animation finished\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\n            if (sprite->animationLooping || sprite->animation->looping) {\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\n            } else {\n                sprite->animationTime = sprite->animation->totalDuration;\n                sprite->animationPlaying = false;\n                \n                // Play next animation if specified\n                if (sprite->animation->nextAnimation) {\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\n                }\n            }\n        }\n        \n        // Update current frame\n        sprite_component_update_animation_frame(sprite);\n    }\n    \n    // Update transform cache if dirty\n    if (sprite->transformDirty) {\n        sprite_component_update_transform_cache(sprite);\n    }\n}\n\nstatic void sprite_component_render(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite_component_needs_render(sprite) || !g_pd) {\n        return;\n    }\n    \n    // Set rendering properties\n    if (sprite->opacity < 1.0f) {\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\n        // Implementation depends on Playdate's capabilities\n    }\n    \n    // Calculate render position with anchor\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\n    \n    // Render sprite\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\n        // Render with source rectangle (sprite sheet)\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    } else {\n        // Render full bitmap\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    }\n}\n\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\n    if (!sprite) {\n        return false;\n    }\n    \n    sprite->bitmap = bitmap;\n    \n    if (bitmap && g_pd) {\n        // Update source rectangle to match bitmap size if not set\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\n            int width, height;\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\n        }\n        \n        sprite_component_mark_transform_dirty(sprite);\n    }\n    \n    return true;\n}\n\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\n    if (!sprite || !path || !g_pd) {\n        return false;\n    }\n    \n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\n    if (!bitmap) {\n        return false;\n    }\n    \n    return sprite_component_set_bitmap(sprite, bitmap);\n}\n\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\n    if (!sprite) return;\n    \n    sprite->sourceRect = (LCDRect){x, y, width, height};\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\n    if (!sprite) return;\n    \n    sprite->anchorX = anchorX;\n    sprite->anchorY = anchorY;\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\n    if (!sprite || !animation) {\n        return false;\n    }\n    \n    sprite->animation = animation;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = true;\n    sprite->animationLooping = animation->looping;\n    \n    // Set first frame\n    if (animation->frameCount > 0) {\n        SpriteFrame* frame = &animation->frames[0];\n        sprite_component_set_source_rect(sprite, \n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n    \n    return true;\n}\n\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\n    if (sprite) {\n        sprite->visible = visible;\n    }\n}\n\n// Helper function to update animation frame\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\n        return;\n    }\n    \n    // Find current frame based on time\n    float accumulatedTime = 0.0f;\n    uint32_t frameIndex = 0;\n    \n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\n        accumulatedTime += sprite->animation->frames[i].duration;\n        if (sprite->animationTime < accumulatedTime) {\n            frameIndex = i;\n            break;\n        }\n    }\n    \n    // Update frame if changed\n    if (frameIndex != sprite->currentFrame) {\n        sprite->currentFrame = frameIndex;\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\n        \n        sprite_component_set_source_rect(sprite,\n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n}\n\n// Helper function to update transform cache\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\n        return;\n    }\n    \n    TransformComponent* transform = sprite->base.gameObject->transform;\n    \n    // Get world position\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\n    \n    // Get render size\n    sprite->renderWidth = (float)sprite->sourceRect.width;\n    sprite->renderHeight = (float)sprite->sourceRect.height;\n    \n    // Apply transform scale\n    float scaleX, scaleY;\n    transform_component_get_scale(transform, &scaleX, &scaleY);\n    sprite->renderWidth *= scaleX;\n    sprite->renderHeight *= scaleY;\n    \n    sprite->transformDirty = false;\n}","originalFile":"# Phase 6: Sprite Component\n\n## Objective\n\nImplement a high-performance sprite rendering system with Playdate SDK integration, supporting batch rendering, sprite sheets, animations, and visual effects. This component targets 1000+ sprites per frame with hardware-accelerated rendering and memory-efficient asset management.\n\n## Prerequisites\n\n- **Phase 1**: Memory Management (ObjectPool system)\n- **Phase 2**: Component System (Component architecture)\n- **Phase 3**: GameObject & Transform (Core entities)\n- **Phase 4**: Scene Management (Scene organization)\n- **Phase 5**: Spatial Partitioning (Spatial optimization)\n- Playdate SDK graphics API knowledge\n- Understanding of sprite rendering optimization\n\n## Technical Specifications\n\n### Performance Targets\n- **Sprite rendering**: 1000+ sprites per frame at 30 FPS\n- **Batch rendering**: Minimize draw calls through sprite batching\n- **Memory efficiency**: < 5% overhead for sprite management\n- **Animation updates**: < 10µs per animated sprite\n- **Visibility culling**: Spatial query integration for off-screen culling\n\n### Sprite System Architecture Goals\n- **Playdate integration**: Native LCDBitmap and rendering API usage\n- **Sprite sheet support**: Efficient sub-rectangle rendering\n- **Animation system**: Frame-based and timeline animations\n- **Layering system**: Z-depth sorting and render order\n- **Visual effects**: Alpha, scaling, rotation, color effects\n\n## Code Structure\n\n```\nsrc/components/\n├── sprite_component.h      # Sprite component interface\n├── sprite_component.c      # Sprite implementation\n├── sprite_renderer.h       # Batch rendering system\n├── sprite_renderer.c       # Renderer implementation\n├── sprite_animation.h      # Animation system\n└── sprite_animation.c      # Animation implementation\n\nsrc/assets/\n├── sprite_loader.h         # Asset loading utilities\n├── sprite_loader.c         # Loader implementation\n├── sprite_atlas.h          # Sprite sheet management\n└── sprite_atlas.c          # Atlas implementation\n\ntests/components/\n├── test_sprite_component.c # Sprite component tests\n├── test_sprite_renderer.c  # Renderer tests\n├── test_sprite_animation.c # Animation tests\n└── test_sprite_perf.c      # Performance benchmarks\n\nexamples/\n├── sprite_demo.c           # Basic sprite usage\n├── animation_demo.c        # Animation examples\n└── batch_rendering.c       # Performance optimization demo\n```\n\n## Implementation Steps\n\n### Step 1: Sprite Component Core Structure\n\n```c\n// sprite_component.h\n#ifndef SPRITE_COMPONENT_H\n#define SPRITE_COMPONENT_H\n\n#include \"component.h\"\n#include \"pd_api.h\"\n#include <stdint.h>\n#include <stdbool.h>\n\n// Forward declarations\ntypedef struct SpriteComponent SpriteComponent;\ntypedef struct SpriteAnimation SpriteAnimation;\ntypedef struct SpriteAtlas SpriteAtlas;\n\n// Sprite rendering modes\ntypedef enum {\n    SPRITE_RENDER_NORMAL = 0,\n    SPRITE_RENDER_ADDITIVE,\n    SPRITE_RENDER_MULTIPLY,\n    SPRITE_RENDER_SUBTRACT,\n    SPRITE_RENDER_MASK\n} SpriteRenderMode;\n\n// Sprite component structure (128 bytes target)\ntypedef struct SpriteComponent {\n    Component base;                    // 32 bytes - base component\n    \n    // Rendering properties\n    LCDBitmap* bitmap;                // 8 bytes - Playdate bitmap\n    LCDRect sourceRect;               // 16 bytes - Source rectangle {x, y, width, height}\n    float anchorX, anchorY;           // 8 bytes - Anchor point (0.0-1.0)\n    LCDBitmapFlip flip;               // 4 bytes - Horizontal/vertical flip\n    float opacity;                    // 4 bytes - Alpha value (0.0-1.0)\n    SpriteRenderMode renderMode;      // 4 bytes - Blend mode\n    \n    // Transform cache (for performance)\n    float renderX, renderY;           // 8 bytes - Cached render position\n    float renderWidth, renderHeight;  // 8 bytes - Cached render size\n    bool transformDirty;              // 1 byte - Needs position recalculation\n    \n    // Animation system\n    SpriteAnimation* animation;       // 8 bytes - Current animation\n    float animationTime;              // 4 bytes - Current animation time\n    uint32_t currentFrame;            // 4 bytes - Current frame index\n    bool animationPlaying;            // 1 byte - Animation state\n    bool animationLooping;            // 1 byte - Loop flag\n    \n    // Sprite sheet support\n    SpriteAtlas* atlas;               // 8 bytes - Sprite atlas reference\n    uint32_t atlasIndex;              // 4 bytes - Index in atlas\n    \n    // Rendering optimization\n    bool visible;                     // 1 byte - Visibility flag\n    bool culled;                      // 1 byte - Frustum culled\n    uint32_t renderLayer;             // 4 bytes - Z-depth layer\n    uint32_t sortingOrder;            // 4 bytes - Order within layer\n    \n    // Color and effects\n    uint8_t colorR, colorG, colorB;   // 3 bytes - Color tint (0-255)\n    uint8_t padding[9];               // 9 bytes - Explicit padding to 128 bytes\n    \n} SpriteComponent;\n\n// Sprite animation frame\ntypedef struct SpriteFrame {\n    LCDRect sourceRect;               // Source rectangle in sprite sheet\n    float duration;                   // Frame duration in seconds\n    float anchorX, anchorY;           // Frame-specific anchor point\n} SpriteFrame;\n\n// Sprite animation\ntypedef struct SpriteAnimation {\n    char name[32];                    // Animation name\n    SpriteFrame* frames;              // Array of animation frames\n    uint32_t frameCount;              // Number of frames\n    float totalDuration;              // Total animation duration\n    bool looping;                     // Default looping behavior\n    SpriteAnimation* nextAnimation;   // Animation to play after this one\n} SpriteAnimation;\n\n// Sprite component interface\nSpriteComponent* sprite_component_create(GameObject* gameObject);\nvoid sprite_component_destroy(SpriteComponent* sprite);\n\n// Bitmap management\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap);\nLCDBitmap* sprite_component_get_bitmap(SpriteComponent* sprite);\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path);\n\n// Source rectangle (for sprite sheets)\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height);\nLCDRect sprite_component_get_source_rect(SpriteComponent* sprite);\n\n// Rendering properties\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY);\nvoid sprite_component_get_anchor(SpriteComponent* sprite, float* anchorX, float* anchorY);\nvoid sprite_component_set_flip(SpriteComponent* sprite, LCDBitmapFlip flip);\nLCDBitmapFlip sprite_component_get_flip(SpriteComponent* sprite);\nvoid sprite_component_set_opacity(SpriteComponent* sprite, float opacity);\nfloat sprite_component_get_opacity(SpriteComponent* sprite);\n\n// Animation control\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation);\nvoid sprite_component_stop_animation(SpriteComponent* sprite);\nvoid sprite_component_pause_animation(SpriteComponent* sprite);\nvoid sprite_component_resume_animation(SpriteComponent* sprite);\nbool sprite_component_is_animation_playing(SpriteComponent* sprite);\n\n// Visibility and culling\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible);\nbool sprite_component_is_visible(SpriteComponent* sprite);\nvoid sprite_component_set_render_layer(SpriteComponent* sprite, uint32_t layer);\nuint32_t sprite_component_get_render_layer(SpriteComponent* sprite);\n\n// Color and effects\nvoid sprite_component_set_color(SpriteComponent* sprite, uint8_t r, uint8_t g, uint8_t b);\nvoid sprite_component_get_color(SpriteComponent* sprite, uint8_t* r, uint8_t* g, uint8_t* b);\n\n// Atlas support\nbool sprite_component_set_atlas(SpriteComponent* sprite, SpriteAtlas* atlas, uint32_t index);\n\n// Component system integration\nvoid sprite_component_register(void);\n\n// Fast access helpers\nstatic inline bool sprite_component_needs_render(SpriteComponent* sprite) {\n    return sprite && sprite->visible && !sprite->culled && sprite->bitmap && sprite->opacity > 0.0f;\n}\n\nstatic inline void sprite_component_mark_transform_dirty(SpriteComponent* sprite) {\n    if (sprite) sprite->transformDirty = true;\n}\n\n#endif // SPRITE_COMPONENT_H\n```\n\n### Step 2: Sprite Component Implementation\n\n```c\n// sprite_component.c\n#include \"sprite_component.h\"\n#include \"component_registry.h\"\n#include \"game_object.h\"\n#include \"transform_component.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n// Sprite component vtable\nstatic void sprite_component_init(Component* component, GameObject* gameObject);\nstatic void sprite_component_destroy_impl(Component* component);\nstatic void sprite_component_update(Component* component, float deltaTime);\nstatic void sprite_component_render(Component* component);\n\nstatic const ComponentVTable spriteVTable = {\n    .init = sprite_component_init,\n    .destroy = sprite_component_destroy_impl,\n    .update = sprite_component_update,\n    .render = sprite_component_render,\n    .clone = NULL,\n    .fixedUpdate = NULL,\n    .onEnabled = NULL,\n    .onDisabled = NULL,\n    .onGameObjectDestroyed = NULL,\n    .getSerializedSize = NULL,\n    .serialize = NULL,\n    .deserialize = NULL\n};\n\n// Global Playdate API reference\nstatic PlaydateAPI* g_pd = NULL;\n\nvoid sprite_component_register(void) {\n    component_registry_register_type(\n        COMPONENT_TYPE_SPRITE,\n        sizeof(SpriteComponent),\n        1000, // Pool size\n        &spriteVTable,\n        \"Sprite\"\n    );\n}\n\nvoid sprite_component_set_playdate_api(PlaydateAPI* pd) {\n    g_pd = pd;\n}\n\nSpriteComponent* sprite_component_create(GameObject* gameObject) {\n    Component* baseComponent = component_registry_create(COMPONENT_TYPE_SPRITE, gameObject);\n    return (SpriteComponent*)baseComponent;\n}\n\nstatic void sprite_component_init(Component* component, GameObject* gameObject) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Initialize sprite properties\n    sprite->bitmap = NULL;\\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\\n    sprite->anchorX = 0.5f;\\n    sprite->anchorY = 0.5f;\\n    sprite->flip = kBitmapUnflipped;\\n    sprite->opacity = 1.0f;\\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\\n    \\n    // Initialize cached transform\\n    sprite->renderX = 0.0f;\\n    sprite->renderY = 0.0f;\\n    sprite->renderWidth = 0.0f;\\n    sprite->renderHeight = 0.0f;\\n    sprite->transformDirty = true;\\n    \\n    // Initialize animation\\n    sprite->animation = NULL;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = false;\\n    sprite->animationLooping = false;\\n    \\n    // Initialize atlas\\n    sprite->atlas = NULL;\\n    sprite->atlasIndex = 0;\\n    \\n    // Initialize rendering\\n    sprite->visible = true;\\n    sprite->culled = false;\\n    sprite->renderLayer = 0;\\n    sprite->sortingOrder = 0;\\n    \\n    // Initialize color\\n    sprite->colorR = 255;\\n    sprite->colorG = 255;\\n    sprite->colorB = 255;\\n}\\n\\nstatic void sprite_component_destroy_impl(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    // Note: We don't free the bitmap here as it may be shared\\n    // Bitmap management should be handled by asset management system\\n    sprite->bitmap = NULL;\\n    sprite->animation = NULL;\\n    sprite->atlas = NULL;\\n}\\n\\nstatic void sprite_component_update(Component* component, float deltaTime) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite->visible) {\\n        return;\\n    }\\n    \\n    // Update animation\\n    if (sprite->animationPlaying && sprite->animation) {\\n        sprite->animationTime += deltaTime;\\n        \\n        // Check if animation finished\\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\\n            if (sprite->animationLooping || sprite->animation->looping) {\\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\\n            } else {\\n                sprite->animationTime = sprite->animation->totalDuration;\\n                sprite->animationPlaying = false;\\n                \\n                // Play next animation if specified\\n                if (sprite->animation->nextAnimation) {\\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\\n                }\\n            }\\n        }\\n        \\n        // Update current frame\\n        sprite_component_update_animation_frame(sprite);\\n    }\\n    \\n    // Update transform cache if dirty\\n    if (sprite->transformDirty) {\\n        sprite_component_update_transform_cache(sprite);\\n    }\\n}\\n\\nstatic void sprite_component_render(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite_component_needs_render(sprite) || !g_pd) {\\n        return;\\n    }\\n    \\n    // Set rendering properties\\n    if (sprite->opacity < 1.0f) {\\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\\n        // Implementation depends on Playdate's capabilities\\n    }\\n    \\n    // Calculate render position with anchor\\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\\n    \\n    // Render sprite\\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\\n        // Render with source rectangle (sprite sheet)\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    } else {\\n        // Render full bitmap\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    }\\n}\\n\\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\\n    if (!sprite) {\\n        return false;\\n    }\\n    \\n    sprite->bitmap = bitmap;\\n    \\n    if (bitmap && g_pd) {\\n        // Update source rectangle to match bitmap size if not set\\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\\n            int width, height;\\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\\n        }\\n        \\n        sprite_component_mark_transform_dirty(sprite);\\n    }\\n    \\n    return true;\\n}\\n\\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\\n    if (!sprite || !path || !g_pd) {\\n        return false;\\n    }\\n    \\n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\\n    if (!bitmap) {\\n        return false;\\n    }\\n    \\n    return sprite_component_set_bitmap(sprite, bitmap);\\n}\\n\\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\\n    if (!sprite) return;\\n    \\n    sprite->sourceRect = (LCDRect){x, y, width, height};\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\\n    if (!sprite) return;\\n    \\n    sprite->anchorX = anchorX;\\n    sprite->anchorY = anchorY;\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\\n    if (!sprite || !animation) {\\n        return false;\\n    }\\n    \\n    sprite->animation = animation;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = true;\\n    sprite->animationLooping = animation->looping;\\n    \\n    // Set first frame\\n    if (animation->frameCount > 0) {\\n        SpriteFrame* frame = &animation->frames[0];\\n        sprite_component_set_source_rect(sprite, \\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n    \\n    return true;\\n}\\n\\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\\n    if (sprite) {\\n        sprite->visible = visible;\\n    }\\n}\\n\\n// Helper function to update animation frame\\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\\n        return;\\n    }\\n    \\n    // Find current frame based on time\\n    float accumulatedTime = 0.0f;\\n    uint32_t frameIndex = 0;\\n    \\n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\\n        accumulatedTime += sprite->animation->frames[i].duration;\\n        if (sprite->animationTime < accumulatedTime) {\\n            frameIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    // Update frame if changed\\n    if (frameIndex != sprite->currentFrame) {\\n        sprite->currentFrame = frameIndex;\\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\\n        \\n        sprite_component_set_source_rect(sprite,\\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n}\\n\\n// Helper function to update transform cache\\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\\n        return;\\n    }\\n    \\n    TransformComponent* transform = sprite->base.gameObject->transform;\\n    \\n    // Get world position\\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\\n    \\n    // Get render size\\n    sprite->renderWidth = (float)sprite->sourceRect.width;\\n    sprite->renderHeight = (float)sprite->sourceRect.height;\\n    \\n    // Apply transform scale\\n    float scaleX, scaleY;\\n    transform_component_get_scale(transform, &scaleX, &scaleY);\\n    sprite->renderWidth *= scaleX;\\n    sprite->renderHeight *= scaleY;\\n    \\n    sprite->transformDirty = false;\\n}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","structuredPatch":[{"oldStart":259,"oldLines":4,"newStart":259,"newLines":249,"lines":["     SpriteComponent* sprite = (SpriteComponent*)component;","     ","     // Initialize sprite properties","-    sprite->bitmap = NULL;\\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\\n    sprite->anchorX = 0.5f;\\n    sprite->anchorY = 0.5f;\\n    sprite->flip = kBitmapUnflipped;\\n    sprite->opacity = 1.0f;\\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\\n    \\n    // Initialize cached transform\\n    sprite->renderX = 0.0f;\\n    sprite->renderY = 0.0f;\\n    sprite->renderWidth = 0.0f;\\n    sprite->renderHeight = 0.0f;\\n    sprite->transformDirty = true;\\n    \\n    // Initialize animation\\n    sprite->animation = NULL;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = false;\\n    sprite->animationLooping = false;\\n    \\n    // Initialize atlas\\n    sprite->atlas = NULL;\\n    sprite->atlasIndex = 0;\\n    \\n    // Initialize rendering\\n    sprite->visible = true;\\n    sprite->culled = false;\\n    sprite->renderLayer = 0;\\n    sprite->sortingOrder = 0;\\n    \\n    // Initialize color\\n    sprite->colorR = 255;\\n    sprite->colorG = 255;\\n    sprite->colorB = 255;\\n}\\n\\nstatic void sprite_component_destroy_impl(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    // Note: We don't free the bitmap here as it may be shared\\n    // Bitmap management should be handled by asset management system\\n    sprite->bitmap = NULL;\\n    sprite->animation = NULL;\\n    sprite->atlas = NULL;\\n}\\n\\nstatic void sprite_component_update(Component* component, float deltaTime) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite->visible) {\\n        return;\\n    }\\n    \\n    // Update animation\\n    if (sprite->animationPlaying && sprite->animation) {\\n        sprite->animationTime += deltaTime;\\n        \\n        // Check if animation finished\\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\\n            if (sprite->animationLooping || sprite->animation->looping) {\\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\\n            } else {\\n                sprite->animationTime = sprite->animation->totalDuration;\\n                sprite->animationPlaying = false;\\n                \\n                // Play next animation if specified\\n                if (sprite->animation->nextAnimation) {\\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\\n                }\\n            }\\n        }\\n        \\n        // Update current frame\\n        sprite_component_update_animation_frame(sprite);\\n    }\\n    \\n    // Update transform cache if dirty\\n    if (sprite->transformDirty) {\\n        sprite_component_update_transform_cache(sprite);\\n    }\\n}\\n\\nstatic void sprite_component_render(Component* component) {\\n    SpriteComponent* sprite = (SpriteComponent*)component;\\n    \\n    if (!sprite_component_needs_render(sprite) || !g_pd) {\\n        return;\\n    }\\n    \\n    // Set rendering properties\\n    if (sprite->opacity < 1.0f) {\\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\\n        // Implementation depends on Playdate's capabilities\\n    }\\n    \\n    // Calculate render position with anchor\\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\\n    \\n    // Render sprite\\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\\n        // Render with source rectangle (sprite sheet)\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    } else {\\n        // Render full bitmap\\n        g_pd->graphics->drawBitmap(sprite->bitmap, \\n                                 (int)renderX, (int)renderY, \\n                                 sprite->flip);\\n    }\\n}\\n\\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\\n    if (!sprite) {\\n        return false;\\n    }\\n    \\n    sprite->bitmap = bitmap;\\n    \\n    if (bitmap && g_pd) {\\n        // Update source rectangle to match bitmap size if not set\\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\\n            int width, height;\\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\\n        }\\n        \\n        sprite_component_mark_transform_dirty(sprite);\\n    }\\n    \\n    return true;\\n}\\n\\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\\n    if (!sprite || !path || !g_pd) {\\n        return false;\\n    }\\n    \\n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\\n    if (!bitmap) {\\n        return false;\\n    }\\n    \\n    return sprite_component_set_bitmap(sprite, bitmap);\\n}\\n\\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\\n    if (!sprite) return;\\n    \\n    sprite->sourceRect = (LCDRect){x, y, width, height};\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\\n    if (!sprite) return;\\n    \\n    sprite->anchorX = anchorX;\\n    sprite->anchorY = anchorY;\\n    sprite_component_mark_transform_dirty(sprite);\\n}\\n\\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\\n    if (!sprite || !animation) {\\n        return false;\\n    }\\n    \\n    sprite->animation = animation;\\n    sprite->animationTime = 0.0f;\\n    sprite->currentFrame = 0;\\n    sprite->animationPlaying = true;\\n    sprite->animationLooping = animation->looping;\\n    \\n    // Set first frame\\n    if (animation->frameCount > 0) {\\n        SpriteFrame* frame = &animation->frames[0];\\n        sprite_component_set_source_rect(sprite, \\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n    \\n    return true;\\n}\\n\\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\\n    if (sprite) {\\n        sprite->visible = visible;\\n    }\\n}\\n\\n// Helper function to update animation frame\\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\\n        return;\\n    }\\n    \\n    // Find current frame based on time\\n    float accumulatedTime = 0.0f;\\n    uint32_t frameIndex = 0;\\n    \\n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\\n        accumulatedTime += sprite->animation->frames[i].duration;\\n        if (sprite->animationTime < accumulatedTime) {\\n            frameIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    // Update frame if changed\\n    if (frameIndex != sprite->currentFrame) {\\n        sprite->currentFrame = frameIndex;\\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\\n        \\n        sprite_component_set_source_rect(sprite,\\n                                        frame->sourceRect.x, frame->sourceRect.y,\\n                                        frame->sourceRect.width, frame->sourceRect.height);\\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\\n    }\\n}\\n\\n// Helper function to update transform cache\\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\\n        return;\\n    }\\n    \\n    TransformComponent* transform = sprite->base.gameObject->transform;\\n    \\n    // Get world position\\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\\n    \\n    // Get render size\\n    sprite->renderWidth = (float)sprite->sourceRect.width;\\n    sprite->renderHeight = (float)sprite->sourceRect.height;\\n    \\n    // Apply transform scale\\n    float scaleX, scaleY;\\n    transform_component_get_scale(transform, &scaleX, &scaleY);\\n    sprite->renderWidth *= scaleX;\\n    sprite->renderHeight *= scaleY;\\n    \\n    sprite->transformDirty = false;\\n}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","\\ No newline at end of file","+    sprite->bitmap = NULL;","+    sprite->sourceRect = (LCDRect){0, 0, 0, 0};","+    sprite->anchorX = 0.5f;","+    sprite->anchorY = 0.5f;","+    sprite->flip = kBitmapUnflipped;","+    sprite->opacity = 1.0f;","+    sprite->renderMode = SPRITE_RENDER_NORMAL;","+    ","+    // Initialize cached transform","+    sprite->renderX = 0.0f;","+    sprite->renderY = 0.0f;","+    sprite->renderWidth = 0.0f;","+    sprite->renderHeight = 0.0f;","+    sprite->transformDirty = true;","+    ","+    // Initialize animation","+    sprite->animation = NULL;","+    sprite->animationTime = 0.0f;","+    sprite->currentFrame = 0;","+    sprite->animationPlaying = false;","+    sprite->animationLooping = false;","+    ","+    // Initialize atlas","+    sprite->atlas = NULL;","+    sprite->atlasIndex = 0;","+    ","+    // Initialize rendering","+    sprite->visible = true;","+    sprite->culled = false;","+    sprite->renderLayer = 0;","+    sprite->sortingOrder = 0;","+    ","+    // Initialize color","+    sprite->colorR = 255;","+    sprite->colorG = 255;","+    sprite->colorB = 255;","+}","+","+static void sprite_component_destroy_impl(Component* component) {","+    SpriteComponent* sprite = (SpriteComponent*)component;","+    ","+    // Note: We don't free the bitmap here as it may be shared","+    // Bitmap management should be handled by asset management system","+    sprite->bitmap = NULL;","+    sprite->animation = NULL;","+    sprite->atlas = NULL;","+}","+","+static void sprite_component_update(Component* component, float deltaTime) {","+    SpriteComponent* sprite = (SpriteComponent*)component;","+    ","+    if (!sprite->visible) {","+        return;","+    }","+    ","+    // Update animation","+    if (sprite->animationPlaying && sprite->animation) {","+        sprite->animationTime += deltaTime;","+        ","+        // Check if animation finished","+        if (sprite->animationTime >= sprite->animation->totalDuration) {","+            if (sprite->animationLooping || sprite->animation->looping) {","+                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);","+            } else {","+                sprite->animationTime = sprite->animation->totalDuration;","+                sprite->animationPlaying = false;","+                ","+                // Play next animation if specified","+                if (sprite->animation->nextAnimation) {","+                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);","+                }","+            }","+        }","+        ","+        // Update current frame","+        sprite_component_update_animation_frame(sprite);","+    }","+    ","+    // Update transform cache if dirty","+    if (sprite->transformDirty) {","+        sprite_component_update_transform_cache(sprite);","+    }","+}","+","+static void sprite_component_render(Component* component) {","+    SpriteComponent* sprite = (SpriteComponent*)component;","+    ","+    if (!sprite_component_needs_render(sprite) || !g_pd) {","+        return;","+    }","+    ","+    // Set rendering properties","+    if (sprite->opacity < 1.0f) {","+        // Handle transparency (Playdate is 1-bit, so this might be dithering)","+        // Implementation depends on Playdate's capabilities","+    }","+    ","+    // Calculate render position with anchor","+    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);","+    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);","+    ","+    // Render sprite","+    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {","+        // Render with source rectangle (sprite sheet)","+        g_pd->graphics->drawBitmap(sprite->bitmap, ","+                                 (int)renderX, (int)renderY, ","+                                 sprite->flip);","+    } else {","+        // Render full bitmap","+        g_pd->graphics->drawBitmap(sprite->bitmap, ","+                                 (int)renderX, (int)renderY, ","+                                 sprite->flip);","+    }","+}","+","+bool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {","+    if (!sprite) {","+        return false;","+    }","+    ","+    sprite->bitmap = bitmap;","+    ","+    if (bitmap && g_pd) {","+        // Update source rectangle to match bitmap size if not set","+        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {","+            int width, height;","+            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);","+            sprite->sourceRect = (LCDRect){0, 0, width, height};","+        }","+        ","+        sprite_component_mark_transform_dirty(sprite);","+    }","+    ","+    return true;","+}","+","+bool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {","+    if (!sprite || !path || !g_pd) {","+        return false;","+    }","+    ","+    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);","+    if (!bitmap) {","+        return false;","+    }","+    ","+    return sprite_component_set_bitmap(sprite, bitmap);","+}","+","+void sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {","+    if (!sprite) return;","+    ","+    sprite->sourceRect = (LCDRect){x, y, width, height};","+    sprite_component_mark_transform_dirty(sprite);","+}","+","+void sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {","+    if (!sprite) return;","+    ","+    sprite->anchorX = anchorX;","+    sprite->anchorY = anchorY;","+    sprite_component_mark_transform_dirty(sprite);","+}","+","+bool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {","+    if (!sprite || !animation) {","+        return false;","+    }","+    ","+    sprite->animation = animation;","+    sprite->animationTime = 0.0f;","+    sprite->currentFrame = 0;","+    sprite->animationPlaying = true;","+    sprite->animationLooping = animation->looping;","+    ","+    // Set first frame","+    if (animation->frameCount > 0) {","+        SpriteFrame* frame = &animation->frames[0];","+        sprite_component_set_source_rect(sprite, ","+                                        frame->sourceRect.x, frame->sourceRect.y,","+                                        frame->sourceRect.width, frame->sourceRect.height);","+        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);","+    }","+    ","+    return true;","+}","+","+void sprite_component_set_visible(SpriteComponent* sprite, bool visible) {","+    if (sprite) {","+        sprite->visible = visible;","+    }","+}","+","+// Helper function to update animation frame","+static void sprite_component_update_animation_frame(SpriteComponent* sprite) {","+    if (!sprite->animation || sprite->animation->frameCount == 0) {","+        return;","+    }","+    ","+    // Find current frame based on time","+    float accumulatedTime = 0.0f;","+    uint32_t frameIndex = 0;","+    ","+    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {","+        accumulatedTime += sprite->animation->frames[i].duration;","+        if (sprite->animationTime < accumulatedTime) {","+            frameIndex = i;","+            break;","+        }","+    }","+    ","+    // Update frame if changed","+    if (frameIndex != sprite->currentFrame) {","+        sprite->currentFrame = frameIndex;","+        SpriteFrame* frame = &sprite->animation->frames[frameIndex];","+        ","+        sprite_component_set_source_rect(sprite,","+                                        frame->sourceRect.x, frame->sourceRect.y,","+                                        frame->sourceRect.width, frame->sourceRect.height);","+        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);","+    }","+}","+","+// Helper function to update transform cache","+static void sprite_component_update_transform_cache(SpriteComponent* sprite) {","+    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {","+        return;","+    }","+    ","+    TransformComponent* transform = sprite->base.gameObject->transform;","+    ","+    // Get world position","+    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);","+    ","+    // Get render size","+    sprite->renderWidth = (float)sprite->sourceRect.width;","+    sprite->renderHeight = (float)sprite->sourceRect.height;","+    ","+    // Apply transform scale","+    float scaleX, scaleY;","+    transform_component_get_scale(transform, &scaleX, &scaleY);","+    sprite->renderWidth *= scaleX;","+    sprite->renderHeight *= scaleY;","+    ","+    sprite->transformDirty = false;","+}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","\\ No newline at end of file"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"bb4bab03-0743-4e59-bf12-446ebdd1271b","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01BCxBVXpuE2ZFDcXDMpJAog","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now I need to fix the remaining sections that still have escaped characters. Let me continue with the rest of the file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":12351,"cache_read_input_tokens":36547,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS1NEbH5oAXx7ssiQSxy7","type":"assistant","uuid":"6d52486a-f697-4936-a971-fe4cdeaf1915","timestamp":"2025-08-11T05:25:58.019Z"}
{"parentUuid":"6d52486a-f697-4936-a971-fe4cdeaf1915","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01BCxBVXpuE2ZFDcXDMpJAog","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01DSz5Lxg9ePiQHXQt8xaG5N","name":"Edit","input":{"file_path":"/Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md","old_string":"}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}","new_string":"}\n```\n\n### Step 3: Sprite Renderer (Batch System)\n\n```c\n// sprite_renderer.h\n#ifndef SPRITE_RENDERER_H\n#define SPRITE_RENDERER_H\n\n#include \"sprite_component.h\"\n#include \"spatial_grid.h\"\n#include \"pd_api.h\"\n\n#define MAX_SPRITES_PER_BATCH 256\n#define MAX_RENDER_LAYERS 16\n\n// Sprite batch for efficient rendering\ntypedef struct SpriteBatch {\n    SpriteComponent** sprites;     // Array of sprites to render\n    uint32_t spriteCount;         // Number of sprites in batch\n    uint32_t capacity;            // Maximum sprites in batch\n    uint32_t renderLayer;         // Layer this batch renders\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\n} SpriteBatch;\n\n// Sprite renderer system\ntypedef struct SpriteRenderer {\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\n    uint32_t activeBatches;                 // Number of active batches\n    \n    // Culling support\n    SpatialGrid* spatialGrid;               // For frustum culling\n    LCDRect viewportRect;                   // Camera viewport\n    bool frustumCullingEnabled;\n    \n    // Performance statistics\n    uint32_t spritesRendered;\n    uint32_t spritesculled;\n    uint32_t drawCalls;\n    float lastRenderTime;\n    \n    // Playdate API reference\n    PlaydateAPI* pd;\n    \n} SpriteRenderer;\n\n// Renderer management\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\n\n// Rendering operations\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\n\n// Viewport and culling\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\n\n// Performance and debugging\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\n\n#endif // SPRITE_RENDERER_H\n```\n\n## Unit Tests\n\n### Sprite Component Tests\n\n```c\n// tests/components/test_sprite_component.c\n#include \"sprite_component.h\"\n#include \"game_object.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// Mock Playdate API for testing\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\n\nvoid test_sprite_component_creation(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    \n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    assert(sprite != NULL);\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\n    assert(sprite->visible == true);\n    assert(sprite->opacity == 1.0f);\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\n    assert(sprite->renderLayer == 0);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite component creation test passed\\n\");\n}\n\nvoid test_sprite_bitmap_management(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Test bitmap setting\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\n    assert(result == true);\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\n    \n    // Test source rectangle\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\n    LCDRect rect = sprite_component_get_source_rect(sprite);\n    assert(rect.x == 10 && rect.y == 20);\n    assert(rect.width == 64 && rect.height == 48);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite bitmap management test passed\\n\");\n}\n\nvoid test_sprite_rendering_properties(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Test anchor\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\n    float anchorX, anchorY;\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\n    assert(anchorX == 0.0f && anchorY == 1.0f);\n    \n    // Test opacity\n    sprite_component_set_opacity(sprite, 0.5f);\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\n    \n    // Test visibility\n    sprite_component_set_visible(sprite, false);\n    assert(sprite_component_is_visible(sprite) == false);\n    \n    // Test render layer\n    sprite_component_set_render_layer(sprite, 5);\n    assert(sprite_component_get_render_layer(sprite) == 5);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite rendering properties test passed\\n\");\n}\n\nvoid test_sprite_animation_system(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Create test animation\n    SpriteAnimation animation;\n    strcpy(animation.name, \"test_anim\");\n    animation.frameCount = 3;\n    animation.looping = true;\n    animation.nextAnimation = NULL;\n    \n    SpriteFrame frames[3] = {\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\n    };\n    animation.frames = frames;\n    animation.totalDuration = 0.3f;\n    \n    // Test animation playback\n    bool result = sprite_component_play_animation(sprite, &animation);\n    assert(result == true);\n    assert(sprite_component_is_animation_playing(sprite) == true);\n    assert(sprite->currentFrame == 0);\n    \n    // Simulate time progression\n    Component* baseComponent = (Component*)sprite;\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\n    assert(sprite->currentFrame == 1);\n    \n    sprite_component_stop_animation(sprite);\n    assert(sprite_component_is_animation_playing(sprite) == false);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite animation system test passed\\n\");\n}\n```\n\n### Performance Tests\n\n```c\n// tests/components/test_sprite_perf.c\n#include \"sprite_component.h\"\n#include \"sprite_renderer.h\"\n#include <time.h>\n#include <stdio.h>\n\nvoid benchmark_sprite_updates(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    SpriteComponent* sprites[1000];\n    \n    // Create many sprites\n    for (int i = 0; i < 1000; i++) {\n        GameObject* obj = game_object_create(scene);\n        sprites[i] = sprite_component_create(obj);\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\n    }\n    \n    clock_t start = clock();\n    \n    // Update all sprites for 100 frames\n    for (int frame = 0; frame < 100; frame++) {\n        for (int i = 0; i < 1000; i++) {\n            Component* baseComponent = (Component*)sprites[i];\n            sprite_component_update(baseComponent, 0.016f);\n        }\n    }\n    \n    clock_t end = clock();\n    \n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n    double per_frame = time_taken / 100;\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\n    \n    printf(\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\n\", \n           per_frame, per_sprite);\n    \n    // Verify performance target\n    assert(per_sprite < 10); // Less than 10μs per sprite update\n    \n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite update performance test passed\\n\");\n}\n\nvoid benchmark_sprite_rendering(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    // Mock Playdate API setup would go here\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\n    \n    Scene* scene = mock_scene_create();\n    SpriteComponent* sprites[1000];\n    \n    // Create sprites\n    for (int i = 0; i < 1000; i++) {\n        GameObject* obj = game_object_create(scene);\n        sprites[i] = sprite_component_create(obj);\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\n    }\n    \n    clock_t start = clock();\n    \n    // Render sprites for 60 frames\n    for (int frame = 0; frame < 60; frame++) {\n        sprite_renderer_begin_frame(renderer);\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\n        sprite_renderer_end_frame(renderer);\n    }\n    \n    clock_t end = clock();\n    \n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n    double per_frame = time_taken / 60;\n    \n    printf(\"Sprite rendering: %.2f ms per frame (1000 sprites)\\n\", per_frame);\n    \n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\n    assert(per_frame < 33);\n    \n    sprite_renderer_destroy(renderer);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite rendering performance test passed\\n\");\n}"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":12351,"cache_read_input_tokens":36547,"output_tokens":6410,"service_tier":"standard"}},"requestId":"req_011CS1NEbH5oAXx7ssiQSxy7","type":"assistant","uuid":"7897943b-7fc9-4fc6-a581-0350cfde99e9","timestamp":"2025-08-11T05:26:55.176Z"}
{"parentUuid":"7897943b-7fc9-4fc6-a581-0350cfde99e9","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DSz5Lxg9ePiQHXQt8xaG5N","type":"tool_result","content":"The file /Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   503→    sprite->renderWidth *= scaleX;\n   504→    sprite->renderHeight *= scaleY;\n   505→    \n   506→    sprite->transformDirty = false;\n   507→}\n   508→```\n   509→\n   510→### Step 3: Sprite Renderer (Batch System)\n   511→\n   512→```c\n   513→// sprite_renderer.h\n   514→#ifndef SPRITE_RENDERER_H\n   515→#define SPRITE_RENDERER_H\n   516→\n   517→#include \"sprite_component.h\"\n   518→#include \"spatial_grid.h\"\n   519→#include \"pd_api.h\"\n   520→\n   521→#define MAX_SPRITES_PER_BATCH 256\n   522→#define MAX_RENDER_LAYERS 16\n   523→\n   524→// Sprite batch for efficient rendering\n   525→typedef struct SpriteBatch {\n   526→    SpriteComponent** sprites;     // Array of sprites to render\n   527→    uint32_t spriteCount;         // Number of sprites in batch\n   528→    uint32_t capacity;            // Maximum sprites in batch\n   529→    uint32_t renderLayer;         // Layer this batch renders\n   530→    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\n   531→} SpriteBatch;\n   532→\n   533→// Sprite renderer system\n   534→typedef struct SpriteRenderer {\n   535→    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\n   536→    uint32_t activeBatches;                 // Number of active batches\n   537→    \n   538→    // Culling support\n   539→    SpatialGrid* spatialGrid;               // For frustum culling\n   540→    LCDRect viewportRect;                   // Camera viewport\n   541→    bool frustumCullingEnabled;\n   542→    \n   543→    // Performance statistics\n   544→    uint32_t spritesRendered;\n   545→    uint32_t spritesculled;\n   546→    uint32_t drawCalls;\n   547→    float lastRenderTime;\n   548→    \n   549→    // Playdate API reference\n   550→    PlaydateAPI* pd;\n   551→    \n   552→} SpriteRenderer;\n   553→\n   554→// Renderer management\n   555→SpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\n   556→void sprite_renderer_destroy(SpriteRenderer* renderer);\n   557→\n   558→// Rendering operations\n   559→void sprite_renderer_begin_frame(SpriteRenderer* renderer);\n   560→void sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\n   561→void sprite_renderer_end_frame(SpriteRenderer* renderer);\n   562→\n   563→// Viewport and culling\n   564→void sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\n   565→void sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\n   566→\n   567→// Performance and debugging\n   568→void sprite_renderer_print_stats(SpriteRenderer* renderer);\n   569→void sprite_renderer_reset_stats(SpriteRenderer* renderer);\n   570→\n   571→#endif // SPRITE_RENDERER_H\n   572→```\n   573→\n   574→## Unit Tests\n   575→\n   576→### Sprite Component Tests\n   577→\n   578→```c\n   579→// tests/components/test_sprite_component.c\n   580→#include \"sprite_component.h\"\n   581→#include \"game_object.h\"\n   582→#include <assert.h>\n   583→#include <stdio.h>\n   584→\n   585→// Mock Playdate API for testing\n   586→static LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\n   587→\n   588→void test_sprite_component_creation(void) {\n   589→    component_registry_init();\n   590→    sprite_component_register();\n   591→    \n   592→    Scene* scene = mock_scene_create();\n   593→    GameObject* gameObject = game_object_create(scene);\n   594→    \n   595→    SpriteComponent* sprite = sprite_component_create(gameObject);\n   596→    assert(sprite != NULL);\n   597→    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\n   598→    assert(sprite->visible == true);\n   599→    assert(sprite->opacity == 1.0f);\n   600→    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\n   601→    assert(sprite->renderLayer == 0);\n   602→    \n   603→    game_object_destroy(gameObject);\n   604→    mock_scene_destroy(scene);\n   605→    component_registry_shutdown();\n   606→    printf(\"✓ Sprite component creation test passed\\n\");\n   607→}\n   608→\n   609→void test_sprite_bitmap_management(void) {\n   610→    component_registry_init();\n   611→    sprite_component_register();\n   612→    \n   613→    Scene* scene = mock_scene_create();\n   614→    GameObject* gameObject = game_object_create(scene);\n   615→    SpriteComponent* sprite = sprite_component_create(gameObject);\n   616→    \n   617→    // Test bitmap setting\n   618→    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\n   619→    assert(result == true);\n   620→    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\n   621→    \n   622→    // Test source rectangle\n   623→    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\n   624→    LCDRect rect = sprite_component_get_source_rect(sprite);\n   625→    assert(rect.x == 10 && rect.y == 20);\n   626→    assert(rect.width == 64 && rect.height == 48);\n   627→    \n   628→    game_object_destroy(gameObject);\n   629→    mock_scene_destroy(scene);\n   630→    component_registry_shutdown();\n   631→    printf(\"✓ Sprite bitmap management test passed\\n\");\n   632→}\n   633→\n   634→void test_sprite_rendering_properties(void) {\n   635→    component_registry_init();\n   636→    sprite_component_register();\n   637→    \n   638→    Scene* scene = mock_scene_create();\n   639→    GameObject* gameObject = game_object_create(scene);\n   640→    SpriteComponent* sprite = sprite_component_create(gameObject);\n   641→    \n   642→    // Test anchor\n   643→    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\n   644→    float anchorX, anchorY;\n   645→    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\n   646→    assert(anchorX == 0.0f && anchorY == 1.0f);\n   647→    \n   648→    // Test opacity\n   649→    sprite_component_set_opacity(sprite, 0.5f);\n   650→    assert(sprite_component_get_opacity(sprite) == 0.5f);\n   651→    \n   652→    // Test visibility\n   653→    sprite_component_set_visible(sprite, false);\n   654→    assert(sprite_component_is_visible(sprite) == false);\n   655→    \n   656→    // Test render layer\n   657→    sprite_component_set_render_layer(sprite, 5);\n   658→    assert(sprite_component_get_render_layer(sprite) == 5);\n   659→    \n   660→    game_object_destroy(gameObject);\n   661→    mock_scene_destroy(scene);\n   662→    component_registry_shutdown();\n   663→    printf(\"✓ Sprite rendering properties test passed\\n\");\n   664→}\n   665→\n   666→void test_sprite_animation_system(void) {\n   667→    component_registry_init();\n   668→    sprite_component_register();\n   669→    \n   670→    Scene* scene = mock_scene_create();\n   671→    GameObject* gameObject = game_object_create(scene);\n   672→    SpriteComponent* sprite = sprite_component_create(gameObject);\n   673→    \n   674→    // Create test animation\n   675→    SpriteAnimation animation;\n   676→    strcpy(animation.name, \"test_anim\");\n   677→    animation.frameCount = 3;\n   678→    animation.looping = true;\n   679→    animation.nextAnimation = NULL;\n   680→    \n   681→    SpriteFrame frames[3] = {\n   682→        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n   683→        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n   684→        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\n   685→    };\n   686→    animation.frames = frames;\n   687→    animation.totalDuration = 0.3f;\n   688→    \n   689→    // Test animation playback\n   690→    bool result = sprite_component_play_animation(sprite, &animation);\n   691→    assert(result == true);\n   692→    assert(sprite_component_is_animation_playing(sprite) == true);\n   693→    assert(sprite->currentFrame == 0);\n   694→    \n   695→    // Simulate time progression\n   696→    Component* baseComponent = (Component*)sprite;\n   697→    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\n   698→    assert(sprite->currentFrame == 1);\n   699→    \n   700→    sprite_component_stop_animation(sprite);\n   701→    assert(sprite_component_is_animation_playing(sprite) == false);\n   702→    \n   703→    game_object_destroy(gameObject);\n   704→    mock_scene_destroy(scene);\n   705→    component_registry_shutdown();\n   706→    printf(\"✓ Sprite animation system test passed\\n\");\n   707→}\n   708→```\n   709→\n   710→### Performance Tests\n   711→\n   712→```c\n   713→// tests/components/test_sprite_perf.c\n   714→#include \"sprite_component.h\"\n   715→#include \"sprite_renderer.h\"\n   716→#include <time.h>\n   717→#include <stdio.h>\n   718→\n   719→void benchmark_sprite_updates(void) {\n   720→    component_registry_init();\n   721→    sprite_component_register();\n   722→    \n   723→    Scene* scene = mock_scene_create();\n   724→    SpriteComponent* sprites[1000];\n   725→    \n   726→    // Create many sprites\n   727→    for (int i = 0; i < 1000; i++) {\n   728→        GameObject* obj = game_object_create(scene);\n   729→        sprites[i] = sprite_component_create(obj);\n   730→        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n   731→        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\n   732→    }\n   733→    \n   734→    clock_t start = clock();\n   735→    \n   736→    // Update all sprites for 100 frames\n   737→    for (int frame = 0; frame < 100; frame++) {\n   738→        for (int i = 0; i < 1000; i++) {\n   739→            Component* baseComponent = (Component*)sprites[i];\n   740→            sprite_component_update(baseComponent, 0.016f);\n   741→        }\n   742→    }\n   743→    \n   744→    clock_t end = clock();\n   745→    \n   746→    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n   747→    double per_frame = time_taken / 100;\n   748→    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\n   749→    \n   750→    printf(\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\n\", \n   751→           per_frame, per_sprite);\n   752→    \n   753→    // Verify performance target\n   754→    assert(per_sprite < 10); // Less than 10μs per sprite update\n   755→    \n   756→    mock_scene_destroy(scene);\n   757→    component_registry_shutdown();\n   758→    printf(\"✓ Sprite update performance test passed\\n\");\n   759→}\n   760→\n   761→void benchmark_sprite_rendering(void) {\n   762→    component_registry_init();\n   763→    sprite_component_register();\n   764→    \n   765→    // Mock Playdate API setup would go here\n   766→    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\n   767→    \n   768→    Scene* scene = mock_scene_create();\n   769→    SpriteComponent* sprites[1000];\n   770→    \n   771→    // Create sprites\n   772→    for (int i = 0; i < 1000; i++) {\n   773→        GameObject* obj = game_object_create(scene);\n   774→        sprites[i] = sprite_component_create(obj);\n   775→        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n   776→        game_object_set_position(obj, i % 400, (i / 400) * 32);\n   777→    }\n   778→    \n   779→    clock_t start = clock();\n   780→    \n   781→    // Render sprites for 60 frames\n   782→    for (int frame = 0; frame < 60; frame++) {\n   783→        sprite_renderer_begin_frame(renderer);\n   784→        sprite_renderer_render_sprites(renderer, sprites, 1000);\n   785→        sprite_renderer_end_frame(renderer);\n   786→    }\n   787→    \n   788→    clock_t end = clock();\n   789→    \n   790→    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n   791→    double per_frame = time_taken / 60;\n   792→    \n   793→    printf(\"Sprite rendering: %.2f ms per frame (1000 sprites)\\n\", per_frame);\n   794→    \n   795→    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\n   796→    assert(per_frame < 33);\n   797→    \n   798→    sprite_renderer_destroy(renderer);\n   799→    mock_scene_destroy(scene);\n   800→    component_registry_shutdown();\n   801→    printf(\"✓ Sprite rendering performance test passed\\n\");\n   802→}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform."}]},"uuid":"3adcfad0-68cc-4671-8328-85d5e3e6d6c9","timestamp":"2025-08-11T05:26:55.228Z","toolUseResult":{"filePath":"/Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md","oldString":"}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}","newString":"}\n```\n\n### Step 3: Sprite Renderer (Batch System)\n\n```c\n// sprite_renderer.h\n#ifndef SPRITE_RENDERER_H\n#define SPRITE_RENDERER_H\n\n#include \"sprite_component.h\"\n#include \"spatial_grid.h\"\n#include \"pd_api.h\"\n\n#define MAX_SPRITES_PER_BATCH 256\n#define MAX_RENDER_LAYERS 16\n\n// Sprite batch for efficient rendering\ntypedef struct SpriteBatch {\n    SpriteComponent** sprites;     // Array of sprites to render\n    uint32_t spriteCount;         // Number of sprites in batch\n    uint32_t capacity;            // Maximum sprites in batch\n    uint32_t renderLayer;         // Layer this batch renders\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\n} SpriteBatch;\n\n// Sprite renderer system\ntypedef struct SpriteRenderer {\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\n    uint32_t activeBatches;                 // Number of active batches\n    \n    // Culling support\n    SpatialGrid* spatialGrid;               // For frustum culling\n    LCDRect viewportRect;                   // Camera viewport\n    bool frustumCullingEnabled;\n    \n    // Performance statistics\n    uint32_t spritesRendered;\n    uint32_t spritesculled;\n    uint32_t drawCalls;\n    float lastRenderTime;\n    \n    // Playdate API reference\n    PlaydateAPI* pd;\n    \n} SpriteRenderer;\n\n// Renderer management\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\n\n// Rendering operations\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\n\n// Viewport and culling\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\n\n// Performance and debugging\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\n\n#endif // SPRITE_RENDERER_H\n```\n\n## Unit Tests\n\n### Sprite Component Tests\n\n```c\n// tests/components/test_sprite_component.c\n#include \"sprite_component.h\"\n#include \"game_object.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// Mock Playdate API for testing\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\n\nvoid test_sprite_component_creation(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    \n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    assert(sprite != NULL);\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\n    assert(sprite->visible == true);\n    assert(sprite->opacity == 1.0f);\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\n    assert(sprite->renderLayer == 0);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite component creation test passed\\n\");\n}\n\nvoid test_sprite_bitmap_management(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Test bitmap setting\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\n    assert(result == true);\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\n    \n    // Test source rectangle\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\n    LCDRect rect = sprite_component_get_source_rect(sprite);\n    assert(rect.x == 10 && rect.y == 20);\n    assert(rect.width == 64 && rect.height == 48);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite bitmap management test passed\\n\");\n}\n\nvoid test_sprite_rendering_properties(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Test anchor\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\n    float anchorX, anchorY;\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\n    assert(anchorX == 0.0f && anchorY == 1.0f);\n    \n    // Test opacity\n    sprite_component_set_opacity(sprite, 0.5f);\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\n    \n    // Test visibility\n    sprite_component_set_visible(sprite, false);\n    assert(sprite_component_is_visible(sprite) == false);\n    \n    // Test render layer\n    sprite_component_set_render_layer(sprite, 5);\n    assert(sprite_component_get_render_layer(sprite) == 5);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite rendering properties test passed\\n\");\n}\n\nvoid test_sprite_animation_system(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Create test animation\n    SpriteAnimation animation;\n    strcpy(animation.name, \"test_anim\");\n    animation.frameCount = 3;\n    animation.looping = true;\n    animation.nextAnimation = NULL;\n    \n    SpriteFrame frames[3] = {\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\n    };\n    animation.frames = frames;\n    animation.totalDuration = 0.3f;\n    \n    // Test animation playback\n    bool result = sprite_component_play_animation(sprite, &animation);\n    assert(result == true);\n    assert(sprite_component_is_animation_playing(sprite) == true);\n    assert(sprite->currentFrame == 0);\n    \n    // Simulate time progression\n    Component* baseComponent = (Component*)sprite;\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\n    assert(sprite->currentFrame == 1);\n    \n    sprite_component_stop_animation(sprite);\n    assert(sprite_component_is_animation_playing(sprite) == false);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite animation system test passed\\n\");\n}\n```\n\n### Performance Tests\n\n```c\n// tests/components/test_sprite_perf.c\n#include \"sprite_component.h\"\n#include \"sprite_renderer.h\"\n#include <time.h>\n#include <stdio.h>\n\nvoid benchmark_sprite_updates(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    SpriteComponent* sprites[1000];\n    \n    // Create many sprites\n    for (int i = 0; i < 1000; i++) {\n        GameObject* obj = game_object_create(scene);\n        sprites[i] = sprite_component_create(obj);\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\n    }\n    \n    clock_t start = clock();\n    \n    // Update all sprites for 100 frames\n    for (int frame = 0; frame < 100; frame++) {\n        for (int i = 0; i < 1000; i++) {\n            Component* baseComponent = (Component*)sprites[i];\n            sprite_component_update(baseComponent, 0.016f);\n        }\n    }\n    \n    clock_t end = clock();\n    \n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n    double per_frame = time_taken / 100;\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\n    \n    printf(\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\n\", \n           per_frame, per_sprite);\n    \n    // Verify performance target\n    assert(per_sprite < 10); // Less than 10μs per sprite update\n    \n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite update performance test passed\\n\");\n}\n\nvoid benchmark_sprite_rendering(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    // Mock Playdate API setup would go here\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\n    \n    Scene* scene = mock_scene_create();\n    SpriteComponent* sprites[1000];\n    \n    // Create sprites\n    for (int i = 0; i < 1000; i++) {\n        GameObject* obj = game_object_create(scene);\n        sprites[i] = sprite_component_create(obj);\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\n    }\n    \n    clock_t start = clock();\n    \n    // Render sprites for 60 frames\n    for (int frame = 0; frame < 60; frame++) {\n        sprite_renderer_begin_frame(renderer);\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\n        sprite_renderer_end_frame(renderer);\n    }\n    \n    clock_t end = clock();\n    \n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n    double per_frame = time_taken / 60;\n    \n    printf(\"Sprite rendering: %.2f ms per frame (1000 sprites)\\n\", per_frame);\n    \n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\n    assert(per_frame < 33);\n    \n    sprite_renderer_destroy(renderer);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite rendering performance test passed\\n\");\n}","originalFile":"# Phase 6: Sprite Component\n\n## Objective\n\nImplement a high-performance sprite rendering system with Playdate SDK integration, supporting batch rendering, sprite sheets, animations, and visual effects. This component targets 1000+ sprites per frame with hardware-accelerated rendering and memory-efficient asset management.\n\n## Prerequisites\n\n- **Phase 1**: Memory Management (ObjectPool system)\n- **Phase 2**: Component System (Component architecture)\n- **Phase 3**: GameObject & Transform (Core entities)\n- **Phase 4**: Scene Management (Scene organization)\n- **Phase 5**: Spatial Partitioning (Spatial optimization)\n- Playdate SDK graphics API knowledge\n- Understanding of sprite rendering optimization\n\n## Technical Specifications\n\n### Performance Targets\n- **Sprite rendering**: 1000+ sprites per frame at 30 FPS\n- **Batch rendering**: Minimize draw calls through sprite batching\n- **Memory efficiency**: < 5% overhead for sprite management\n- **Animation updates**: < 10µs per animated sprite\n- **Visibility culling**: Spatial query integration for off-screen culling\n\n### Sprite System Architecture Goals\n- **Playdate integration**: Native LCDBitmap and rendering API usage\n- **Sprite sheet support**: Efficient sub-rectangle rendering\n- **Animation system**: Frame-based and timeline animations\n- **Layering system**: Z-depth sorting and render order\n- **Visual effects**: Alpha, scaling, rotation, color effects\n\n## Code Structure\n\n```\nsrc/components/\n├── sprite_component.h      # Sprite component interface\n├── sprite_component.c      # Sprite implementation\n├── sprite_renderer.h       # Batch rendering system\n├── sprite_renderer.c       # Renderer implementation\n├── sprite_animation.h      # Animation system\n└── sprite_animation.c      # Animation implementation\n\nsrc/assets/\n├── sprite_loader.h         # Asset loading utilities\n├── sprite_loader.c         # Loader implementation\n├── sprite_atlas.h          # Sprite sheet management\n└── sprite_atlas.c          # Atlas implementation\n\ntests/components/\n├── test_sprite_component.c # Sprite component tests\n├── test_sprite_renderer.c  # Renderer tests\n├── test_sprite_animation.c # Animation tests\n└── test_sprite_perf.c      # Performance benchmarks\n\nexamples/\n├── sprite_demo.c           # Basic sprite usage\n├── animation_demo.c        # Animation examples\n└── batch_rendering.c       # Performance optimization demo\n```\n\n## Implementation Steps\n\n### Step 1: Sprite Component Core Structure\n\n```c\n// sprite_component.h\n#ifndef SPRITE_COMPONENT_H\n#define SPRITE_COMPONENT_H\n\n#include \"component.h\"\n#include \"pd_api.h\"\n#include <stdint.h>\n#include <stdbool.h>\n\n// Forward declarations\ntypedef struct SpriteComponent SpriteComponent;\ntypedef struct SpriteAnimation SpriteAnimation;\ntypedef struct SpriteAtlas SpriteAtlas;\n\n// Sprite rendering modes\ntypedef enum {\n    SPRITE_RENDER_NORMAL = 0,\n    SPRITE_RENDER_ADDITIVE,\n    SPRITE_RENDER_MULTIPLY,\n    SPRITE_RENDER_SUBTRACT,\n    SPRITE_RENDER_MASK\n} SpriteRenderMode;\n\n// Sprite component structure (128 bytes target)\ntypedef struct SpriteComponent {\n    Component base;                    // 32 bytes - base component\n    \n    // Rendering properties\n    LCDBitmap* bitmap;                // 8 bytes - Playdate bitmap\n    LCDRect sourceRect;               // 16 bytes - Source rectangle {x, y, width, height}\n    float anchorX, anchorY;           // 8 bytes - Anchor point (0.0-1.0)\n    LCDBitmapFlip flip;               // 4 bytes - Horizontal/vertical flip\n    float opacity;                    // 4 bytes - Alpha value (0.0-1.0)\n    SpriteRenderMode renderMode;      // 4 bytes - Blend mode\n    \n    // Transform cache (for performance)\n    float renderX, renderY;           // 8 bytes - Cached render position\n    float renderWidth, renderHeight;  // 8 bytes - Cached render size\n    bool transformDirty;              // 1 byte - Needs position recalculation\n    \n    // Animation system\n    SpriteAnimation* animation;       // 8 bytes - Current animation\n    float animationTime;              // 4 bytes - Current animation time\n    uint32_t currentFrame;            // 4 bytes - Current frame index\n    bool animationPlaying;            // 1 byte - Animation state\n    bool animationLooping;            // 1 byte - Loop flag\n    \n    // Sprite sheet support\n    SpriteAtlas* atlas;               // 8 bytes - Sprite atlas reference\n    uint32_t atlasIndex;              // 4 bytes - Index in atlas\n    \n    // Rendering optimization\n    bool visible;                     // 1 byte - Visibility flag\n    bool culled;                      // 1 byte - Frustum culled\n    uint32_t renderLayer;             // 4 bytes - Z-depth layer\n    uint32_t sortingOrder;            // 4 bytes - Order within layer\n    \n    // Color and effects\n    uint8_t colorR, colorG, colorB;   // 3 bytes - Color tint (0-255)\n    uint8_t padding[9];               // 9 bytes - Explicit padding to 128 bytes\n    \n} SpriteComponent;\n\n// Sprite animation frame\ntypedef struct SpriteFrame {\n    LCDRect sourceRect;               // Source rectangle in sprite sheet\n    float duration;                   // Frame duration in seconds\n    float anchorX, anchorY;           // Frame-specific anchor point\n} SpriteFrame;\n\n// Sprite animation\ntypedef struct SpriteAnimation {\n    char name[32];                    // Animation name\n    SpriteFrame* frames;              // Array of animation frames\n    uint32_t frameCount;              // Number of frames\n    float totalDuration;              // Total animation duration\n    bool looping;                     // Default looping behavior\n    SpriteAnimation* nextAnimation;   // Animation to play after this one\n} SpriteAnimation;\n\n// Sprite component interface\nSpriteComponent* sprite_component_create(GameObject* gameObject);\nvoid sprite_component_destroy(SpriteComponent* sprite);\n\n// Bitmap management\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap);\nLCDBitmap* sprite_component_get_bitmap(SpriteComponent* sprite);\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path);\n\n// Source rectangle (for sprite sheets)\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height);\nLCDRect sprite_component_get_source_rect(SpriteComponent* sprite);\n\n// Rendering properties\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY);\nvoid sprite_component_get_anchor(SpriteComponent* sprite, float* anchorX, float* anchorY);\nvoid sprite_component_set_flip(SpriteComponent* sprite, LCDBitmapFlip flip);\nLCDBitmapFlip sprite_component_get_flip(SpriteComponent* sprite);\nvoid sprite_component_set_opacity(SpriteComponent* sprite, float opacity);\nfloat sprite_component_get_opacity(SpriteComponent* sprite);\n\n// Animation control\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation);\nvoid sprite_component_stop_animation(SpriteComponent* sprite);\nvoid sprite_component_pause_animation(SpriteComponent* sprite);\nvoid sprite_component_resume_animation(SpriteComponent* sprite);\nbool sprite_component_is_animation_playing(SpriteComponent* sprite);\n\n// Visibility and culling\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible);\nbool sprite_component_is_visible(SpriteComponent* sprite);\nvoid sprite_component_set_render_layer(SpriteComponent* sprite, uint32_t layer);\nuint32_t sprite_component_get_render_layer(SpriteComponent* sprite);\n\n// Color and effects\nvoid sprite_component_set_color(SpriteComponent* sprite, uint8_t r, uint8_t g, uint8_t b);\nvoid sprite_component_get_color(SpriteComponent* sprite, uint8_t* r, uint8_t* g, uint8_t* b);\n\n// Atlas support\nbool sprite_component_set_atlas(SpriteComponent* sprite, SpriteAtlas* atlas, uint32_t index);\n\n// Component system integration\nvoid sprite_component_register(void);\n\n// Fast access helpers\nstatic inline bool sprite_component_needs_render(SpriteComponent* sprite) {\n    return sprite && sprite->visible && !sprite->culled && sprite->bitmap && sprite->opacity > 0.0f;\n}\n\nstatic inline void sprite_component_mark_transform_dirty(SpriteComponent* sprite) {\n    if (sprite) sprite->transformDirty = true;\n}\n\n#endif // SPRITE_COMPONENT_H\n```\n\n### Step 2: Sprite Component Implementation\n\n```c\n// sprite_component.c\n#include \"sprite_component.h\"\n#include \"component_registry.h\"\n#include \"game_object.h\"\n#include \"transform_component.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n// Sprite component vtable\nstatic void sprite_component_init(Component* component, GameObject* gameObject);\nstatic void sprite_component_destroy_impl(Component* component);\nstatic void sprite_component_update(Component* component, float deltaTime);\nstatic void sprite_component_render(Component* component);\n\nstatic const ComponentVTable spriteVTable = {\n    .init = sprite_component_init,\n    .destroy = sprite_component_destroy_impl,\n    .update = sprite_component_update,\n    .render = sprite_component_render,\n    .clone = NULL,\n    .fixedUpdate = NULL,\n    .onEnabled = NULL,\n    .onDisabled = NULL,\n    .onGameObjectDestroyed = NULL,\n    .getSerializedSize = NULL,\n    .serialize = NULL,\n    .deserialize = NULL\n};\n\n// Global Playdate API reference\nstatic PlaydateAPI* g_pd = NULL;\n\nvoid sprite_component_register(void) {\n    component_registry_register_type(\n        COMPONENT_TYPE_SPRITE,\n        sizeof(SpriteComponent),\n        1000, // Pool size\n        &spriteVTable,\n        \"Sprite\"\n    );\n}\n\nvoid sprite_component_set_playdate_api(PlaydateAPI* pd) {\n    g_pd = pd;\n}\n\nSpriteComponent* sprite_component_create(GameObject* gameObject) {\n    Component* baseComponent = component_registry_create(COMPONENT_TYPE_SPRITE, gameObject);\n    return (SpriteComponent*)baseComponent;\n}\n\nstatic void sprite_component_init(Component* component, GameObject* gameObject) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Initialize sprite properties\n    sprite->bitmap = NULL;\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\n    sprite->anchorX = 0.5f;\n    sprite->anchorY = 0.5f;\n    sprite->flip = kBitmapUnflipped;\n    sprite->opacity = 1.0f;\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\n    \n    // Initialize cached transform\n    sprite->renderX = 0.0f;\n    sprite->renderY = 0.0f;\n    sprite->renderWidth = 0.0f;\n    sprite->renderHeight = 0.0f;\n    sprite->transformDirty = true;\n    \n    // Initialize animation\n    sprite->animation = NULL;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = false;\n    sprite->animationLooping = false;\n    \n    // Initialize atlas\n    sprite->atlas = NULL;\n    sprite->atlasIndex = 0;\n    \n    // Initialize rendering\n    sprite->visible = true;\n    sprite->culled = false;\n    sprite->renderLayer = 0;\n    sprite->sortingOrder = 0;\n    \n    // Initialize color\n    sprite->colorR = 255;\n    sprite->colorG = 255;\n    sprite->colorB = 255;\n}\n\nstatic void sprite_component_destroy_impl(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Note: We don't free the bitmap here as it may be shared\n    // Bitmap management should be handled by asset management system\n    sprite->bitmap = NULL;\n    sprite->animation = NULL;\n    sprite->atlas = NULL;\n}\n\nstatic void sprite_component_update(Component* component, float deltaTime) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite->visible) {\n        return;\n    }\n    \n    // Update animation\n    if (sprite->animationPlaying && sprite->animation) {\n        sprite->animationTime += deltaTime;\n        \n        // Check if animation finished\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\n            if (sprite->animationLooping || sprite->animation->looping) {\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\n            } else {\n                sprite->animationTime = sprite->animation->totalDuration;\n                sprite->animationPlaying = false;\n                \n                // Play next animation if specified\n                if (sprite->animation->nextAnimation) {\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\n                }\n            }\n        }\n        \n        // Update current frame\n        sprite_component_update_animation_frame(sprite);\n    }\n    \n    // Update transform cache if dirty\n    if (sprite->transformDirty) {\n        sprite_component_update_transform_cache(sprite);\n    }\n}\n\nstatic void sprite_component_render(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite_component_needs_render(sprite) || !g_pd) {\n        return;\n    }\n    \n    // Set rendering properties\n    if (sprite->opacity < 1.0f) {\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\n        // Implementation depends on Playdate's capabilities\n    }\n    \n    // Calculate render position with anchor\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\n    \n    // Render sprite\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\n        // Render with source rectangle (sprite sheet)\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    } else {\n        // Render full bitmap\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    }\n}\n\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\n    if (!sprite) {\n        return false;\n    }\n    \n    sprite->bitmap = bitmap;\n    \n    if (bitmap && g_pd) {\n        // Update source rectangle to match bitmap size if not set\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\n            int width, height;\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\n        }\n        \n        sprite_component_mark_transform_dirty(sprite);\n    }\n    \n    return true;\n}\n\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\n    if (!sprite || !path || !g_pd) {\n        return false;\n    }\n    \n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\n    if (!bitmap) {\n        return false;\n    }\n    \n    return sprite_component_set_bitmap(sprite, bitmap);\n}\n\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\n    if (!sprite) return;\n    \n    sprite->sourceRect = (LCDRect){x, y, width, height};\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\n    if (!sprite) return;\n    \n    sprite->anchorX = anchorX;\n    sprite->anchorY = anchorY;\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\n    if (!sprite || !animation) {\n        return false;\n    }\n    \n    sprite->animation = animation;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = true;\n    sprite->animationLooping = animation->looping;\n    \n    // Set first frame\n    if (animation->frameCount > 0) {\n        SpriteFrame* frame = &animation->frames[0];\n        sprite_component_set_source_rect(sprite, \n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n    \n    return true;\n}\n\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\n    if (sprite) {\n        sprite->visible = visible;\n    }\n}\n\n// Helper function to update animation frame\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\n        return;\n    }\n    \n    // Find current frame based on time\n    float accumulatedTime = 0.0f;\n    uint32_t frameIndex = 0;\n    \n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\n        accumulatedTime += sprite->animation->frames[i].duration;\n        if (sprite->animationTime < accumulatedTime) {\n            frameIndex = i;\n            break;\n        }\n    }\n    \n    // Update frame if changed\n    if (frameIndex != sprite->currentFrame) {\n        sprite->currentFrame = frameIndex;\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\n        \n        sprite_component_set_source_rect(sprite,\n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n}\n\n// Helper function to update transform cache\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\n        return;\n    }\n    \n    TransformComponent* transform = sprite->base.gameObject->transform;\n    \n    // Get world position\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\n    \n    // Get render size\n    sprite->renderWidth = (float)sprite->sourceRect.width;\n    sprite->renderHeight = (float)sprite->sourceRect.height;\n    \n    // Apply transform scale\n    float scaleX, scaleY;\n    transform_component_get_scale(transform, &scaleX, &scaleY);\n    sprite->renderWidth *= scaleX;\n    sprite->renderHeight *= scaleY;\n    \n    sprite->transformDirty = false;\n}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","structuredPatch":[{"oldStart":504,"oldLines":4,"newStart":504,"newLines":299,"lines":["     sprite->renderHeight *= scaleY;","     ","     sprite->transformDirty = false;","-}\\n```\\n\\n### Step 3: Sprite Renderer (Batch System)\\n\\n```c\\n// sprite_renderer.h\\n#ifndef SPRITE_RENDERER_H\\n#define SPRITE_RENDERER_H\\n\\n#include \\\"sprite_component.h\\\"\\n#include \\\"spatial_grid.h\\\"\\n#include \\\"pd_api.h\\\"\\n\\n#define MAX_SPRITES_PER_BATCH 256\\n#define MAX_RENDER_LAYERS 16\\n\\n// Sprite batch for efficient rendering\\ntypedef struct SpriteBatch {\\n    SpriteComponent** sprites;     // Array of sprites to render\\n    uint32_t spriteCount;         // Number of sprites in batch\\n    uint32_t capacity;            // Maximum sprites in batch\\n    uint32_t renderLayer;         // Layer this batch renders\\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\\n} SpriteBatch;\\n\\n// Sprite renderer system\\ntypedef struct SpriteRenderer {\\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\\n    uint32_t activeBatches;                 // Number of active batches\\n    \\n    // Culling support\\n    SpatialGrid* spatialGrid;               // For frustum culling\\n    LCDRect viewportRect;                   // Camera viewport\\n    bool frustumCullingEnabled;\\n    \\n    // Performance statistics\\n    uint32_t spritesRendered;\\n    uint32_t spritesculled;\\n    uint32_t drawCalls;\\n    float lastRenderTime;\\n    \\n    // Playdate API reference\\n    PlaydateAPI* pd;\\n    \\n} SpriteRenderer;\\n\\n// Renderer management\\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\\n\\n// Rendering operations\\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\\n\\n// Viewport and culling\\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\\n\\n// Performance and debugging\\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\\n\\n#endif // SPRITE_RENDERER_H\\n```\\n\\n## Unit Tests\\n\\n### Sprite Component Tests\\n\\n```c\\n// tests/components/test_sprite_component.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"game_object.h\\\"\\n#include <assert.h>\\n#include <stdio.h>\\n\\n// Mock Playdate API for testing\\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\\n\\nvoid test_sprite_component_creation(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    \\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    assert(sprite != NULL);\\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\\n    assert(sprite->visible == true);\\n    assert(sprite->opacity == 1.0f);\\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\\n    assert(sprite->renderLayer == 0);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite component creation test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_bitmap_management(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test bitmap setting\\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\\n    assert(result == true);\\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\\n    \\n    // Test source rectangle\\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\\n    LCDRect rect = sprite_component_get_source_rect(sprite);\\n    assert(rect.x == 10 && rect.y == 20);\\n    assert(rect.width == 64 && rect.height == 48);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite bitmap management test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_rendering_properties(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Test anchor\\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\\n    float anchorX, anchorY;\\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\\n    assert(anchorX == 0.0f && anchorY == 1.0f);\\n    \\n    // Test opacity\\n    sprite_component_set_opacity(sprite, 0.5f);\\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\\n    \\n    // Test visibility\\n    sprite_component_set_visible(sprite, false);\\n    assert(sprite_component_is_visible(sprite) == false);\\n    \\n    // Test render layer\\n    sprite_component_set_render_layer(sprite, 5);\\n    assert(sprite_component_get_render_layer(sprite) == 5);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering properties test passed\\\\n\\\");\\n}\\n\\nvoid test_sprite_animation_system(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    GameObject* gameObject = game_object_create(scene);\\n    SpriteComponent* sprite = sprite_component_create(gameObject);\\n    \\n    // Create test animation\\n    SpriteAnimation animation;\\n    strcpy(animation.name, \\\"test_anim\\\");\\n    animation.frameCount = 3;\\n    animation.looping = true;\\n    animation.nextAnimation = NULL;\\n    \\n    SpriteFrame frames[3] = {\\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\\n    };\\n    animation.frames = frames;\\n    animation.totalDuration = 0.3f;\\n    \\n    // Test animation playback\\n    bool result = sprite_component_play_animation(sprite, &animation);\\n    assert(result == true);\\n    assert(sprite_component_is_animation_playing(sprite) == true);\\n    assert(sprite->currentFrame == 0);\\n    \\n    // Simulate time progression\\n    Component* baseComponent = (Component*)sprite;\\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\\n    assert(sprite->currentFrame == 1);\\n    \\n    sprite_component_stop_animation(sprite);\\n    assert(sprite_component_is_animation_playing(sprite) == false);\\n    \\n    game_object_destroy(gameObject);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite animation system test passed\\\\n\\\");\\n}\\n```\\n\\n### Performance Tests\\n\\n```c\\n// tests/components/test_sprite_perf.c\\n#include \\\"sprite_component.h\\\"\\n#include \\\"sprite_renderer.h\\\"\\n#include <time.h>\\n#include <stdio.h>\\n\\nvoid benchmark_sprite_updates(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create many sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Update all sprites for 100 frames\\n    for (int frame = 0; frame < 100; frame++) {\\n        for (int i = 0; i < 1000; i++) {\\n            Component* baseComponent = (Component*)sprites[i];\\n            sprite_component_update(baseComponent, 0.016f);\\n        }\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 100;\\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\\n    \\n    printf(\\\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\\\n\\\", \\n           per_frame, per_sprite);\\n    \\n    // Verify performance target\\n    assert(per_sprite < 10); // Less than 10μs per sprite update\\n    \\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite update performance test passed\\\\n\\\");\\n}\\n\\nvoid benchmark_sprite_rendering(void) {\\n    component_registry_init();\\n    sprite_component_register();\\n    \\n    // Mock Playdate API setup would go here\\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\\n    \\n    Scene* scene = mock_scene_create();\\n    SpriteComponent* sprites[1000];\\n    \\n    // Create sprites\\n    for (int i = 0; i < 1000; i++) {\\n        GameObject* obj = game_object_create(scene);\\n        sprites[i] = sprite_component_create(obj);\\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\\n    }\\n    \\n    clock_t start = clock();\\n    \\n    // Render sprites for 60 frames\\n    for (int frame = 0; frame < 60; frame++) {\\n        sprite_renderer_begin_frame(renderer);\\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\\n        sprite_renderer_end_frame(renderer);\\n    }\\n    \\n    clock_t end = clock();\\n    \\n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\\n    double per_frame = time_taken / 60;\\n    \\n    printf(\\\"Sprite rendering: %.2f ms per frame (1000 sprites)\\\\n\\\", per_frame);\\n    \\n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\\n    assert(per_frame < 33);\\n    \\n    sprite_renderer_destroy(renderer);\\n    mock_scene_destroy(scene);\\n    component_registry_shutdown();\\n    printf(\\\"✓ Sprite rendering performance test passed\\\\n\\\");\\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","\\ No newline at end of file","+}","+```","+","+### Step 3: Sprite Renderer (Batch System)","+","+```c","+// sprite_renderer.h","+#ifndef SPRITE_RENDERER_H","+#define SPRITE_RENDERER_H","+","+#include \"sprite_component.h\"","+#include \"spatial_grid.h\"","+#include \"pd_api.h\"","+","+#define MAX_SPRITES_PER_BATCH 256","+#define MAX_RENDER_LAYERS 16","+","+// Sprite batch for efficient rendering","+typedef struct SpriteBatch {","+    SpriteComponent** sprites;     // Array of sprites to render","+    uint32_t spriteCount;         // Number of sprites in batch","+    uint32_t capacity;            // Maximum sprites in batch","+    uint32_t renderLayer;         // Layer this batch renders","+    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization","+} SpriteBatch;","+","+// Sprite renderer system","+typedef struct SpriteRenderer {","+    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer","+    uint32_t activeBatches;                 // Number of active batches","+    ","+    // Culling support","+    SpatialGrid* spatialGrid;               // For frustum culling","+    LCDRect viewportRect;                   // Camera viewport","+    bool frustumCullingEnabled;","+    ","+    // Performance statistics","+    uint32_t spritesRendered;","+    uint32_t spritesculled;","+    uint32_t drawCalls;","+    float lastRenderTime;","+    ","+    // Playdate API reference","+    PlaydateAPI* pd;","+    ","+} SpriteRenderer;","+","+// Renderer management","+SpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);","+void sprite_renderer_destroy(SpriteRenderer* renderer);","+","+// Rendering operations","+void sprite_renderer_begin_frame(SpriteRenderer* renderer);","+void sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);","+void sprite_renderer_end_frame(SpriteRenderer* renderer);","+","+// Viewport and culling","+void sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);","+void sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);","+","+// Performance and debugging","+void sprite_renderer_print_stats(SpriteRenderer* renderer);","+void sprite_renderer_reset_stats(SpriteRenderer* renderer);","+","+#endif // SPRITE_RENDERER_H","+```","+","+## Unit Tests","+","+### Sprite Component Tests","+","+```c","+// tests/components/test_sprite_component.c","+#include \"sprite_component.h\"","+#include \"game_object.h\"","+#include <assert.h>","+#include <stdio.h>","+","+// Mock Playdate API for testing","+static LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;","+","+void test_sprite_component_creation(void) {","+    component_registry_init();","+    sprite_component_register();","+    ","+    Scene* scene = mock_scene_create();","+    GameObject* gameObject = game_object_create(scene);","+    ","+    SpriteComponent* sprite = sprite_component_create(gameObject);","+    assert(sprite != NULL);","+    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);","+    assert(sprite->visible == true);","+    assert(sprite->opacity == 1.0f);","+    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);","+    assert(sprite->renderLayer == 0);","+    ","+    game_object_destroy(gameObject);","+    mock_scene_destroy(scene);","+    component_registry_shutdown();","+    printf(\"✓ Sprite component creation test passed\\n\");","+}","+","+void test_sprite_bitmap_management(void) {","+    component_registry_init();","+    sprite_component_register();","+    ","+    Scene* scene = mock_scene_create();","+    GameObject* gameObject = game_object_create(scene);","+    SpriteComponent* sprite = sprite_component_create(gameObject);","+    ","+    // Test bitmap setting","+    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);","+    assert(result == true);","+    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);","+    ","+    // Test source rectangle","+    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);","+    LCDRect rect = sprite_component_get_source_rect(sprite);","+    assert(rect.x == 10 && rect.y == 20);","+    assert(rect.width == 64 && rect.height == 48);","+    ","+    game_object_destroy(gameObject);","+    mock_scene_destroy(scene);","+    component_registry_shutdown();","+    printf(\"✓ Sprite bitmap management test passed\\n\");","+}","+","+void test_sprite_rendering_properties(void) {","+    component_registry_init();","+    sprite_component_register();","+    ","+    Scene* scene = mock_scene_create();","+    GameObject* gameObject = game_object_create(scene);","+    SpriteComponent* sprite = sprite_component_create(gameObject);","+    ","+    // Test anchor","+    sprite_component_set_anchor(sprite, 0.0f, 1.0f);","+    float anchorX, anchorY;","+    sprite_component_get_anchor(sprite, &anchorX, &anchorY);","+    assert(anchorX == 0.0f && anchorY == 1.0f);","+    ","+    // Test opacity","+    sprite_component_set_opacity(sprite, 0.5f);","+    assert(sprite_component_get_opacity(sprite) == 0.5f);","+    ","+    // Test visibility","+    sprite_component_set_visible(sprite, false);","+    assert(sprite_component_is_visible(sprite) == false);","+    ","+    // Test render layer","+    sprite_component_set_render_layer(sprite, 5);","+    assert(sprite_component_get_render_layer(sprite) == 5);","+    ","+    game_object_destroy(gameObject);","+    mock_scene_destroy(scene);","+    component_registry_shutdown();","+    printf(\"✓ Sprite rendering properties test passed\\n\");","+}","+","+void test_sprite_animation_system(void) {","+    component_registry_init();","+    sprite_component_register();","+    ","+    Scene* scene = mock_scene_create();","+    GameObject* gameObject = game_object_create(scene);","+    SpriteComponent* sprite = sprite_component_create(gameObject);","+    ","+    // Create test animation","+    SpriteAnimation animation;","+    strcpy(animation.name, \"test_anim\");","+    animation.frameCount = 3;","+    animation.looping = true;","+    animation.nextAnimation = NULL;","+    ","+    SpriteFrame frames[3] = {","+        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},","+        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},","+        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}","+    };","+    animation.frames = frames;","+    animation.totalDuration = 0.3f;","+    ","+    // Test animation playback","+    bool result = sprite_component_play_animation(sprite, &animation);","+    assert(result == true);","+    assert(sprite_component_is_animation_playing(sprite) == true);","+    assert(sprite->currentFrame == 0);","+    ","+    // Simulate time progression","+    Component* baseComponent = (Component*)sprite;","+    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1","+    assert(sprite->currentFrame == 1);","+    ","+    sprite_component_stop_animation(sprite);","+    assert(sprite_component_is_animation_playing(sprite) == false);","+    ","+    game_object_destroy(gameObject);","+    mock_scene_destroy(scene);","+    component_registry_shutdown();","+    printf(\"✓ Sprite animation system test passed\\n\");","+}","+```","+","+### Performance Tests","+","+```c","+// tests/components/test_sprite_perf.c","+#include \"sprite_component.h\"","+#include \"sprite_renderer.h\"","+#include <time.h>","+#include <stdio.h>","+","+void benchmark_sprite_updates(void) {","+    component_registry_init();","+    sprite_component_register();","+    ","+    Scene* scene = mock_scene_create();","+    SpriteComponent* sprites[1000];","+    ","+    // Create many sprites","+    for (int i = 0; i < 1000; i++) {","+        GameObject* obj = game_object_create(scene);","+        sprites[i] = sprite_component_create(obj);","+        sprite_component_set_bitmap(sprites[i], mock_bitmap);","+        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);","+    }","+    ","+    clock_t start = clock();","+    ","+    // Update all sprites for 100 frames","+    for (int frame = 0; frame < 100; frame++) {","+        for (int i = 0; i < 1000; i++) {","+            Component* baseComponent = (Component*)sprites[i];","+            sprite_component_update(baseComponent, 0.016f);","+        }","+    }","+    ","+    clock_t end = clock();","+    ","+    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds","+    double per_frame = time_taken / 100;","+    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite","+    ","+    printf(\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\n\", ","+           per_frame, per_sprite);","+    ","+    // Verify performance target","+    assert(per_sprite < 10); // Less than 10μs per sprite update","+    ","+    mock_scene_destroy(scene);","+    component_registry_shutdown();","+    printf(\"✓ Sprite update performance test passed\\n\");","+}","+","+void benchmark_sprite_rendering(void) {","+    component_registry_init();","+    sprite_component_register();","+    ","+    // Mock Playdate API setup would go here","+    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);","+    ","+    Scene* scene = mock_scene_create();","+    SpriteComponent* sprites[1000];","+    ","+    // Create sprites","+    for (int i = 0; i < 1000; i++) {","+        GameObject* obj = game_object_create(scene);","+        sprites[i] = sprite_component_create(obj);","+        sprite_component_set_bitmap(sprites[i], mock_bitmap);","+        game_object_set_position(obj, i % 400, (i / 400) * 32);","+    }","+    ","+    clock_t start = clock();","+    ","+    // Render sprites for 60 frames","+    for (int frame = 0; frame < 60; frame++) {","+        sprite_renderer_begin_frame(renderer);","+        sprite_renderer_render_sprites(renderer, sprites, 1000);","+        sprite_renderer_end_frame(renderer);","+    }","+    ","+    clock_t end = clock();","+    ","+    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds","+    double per_frame = time_taken / 60;","+    ","+    printf(\"Sprite rendering: %.2f ms per frame (1000 sprites)\\n\", per_frame);","+    ","+    // Verify performance target: 1000 sprites in < 33ms (30 FPS)","+    assert(per_frame < 33);","+    ","+    sprite_renderer_destroy(renderer);","+    mock_scene_destroy(scene);","+    component_registry_shutdown();","+    printf(\"✓ Sprite rendering performance test passed\\n\");","+}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","\\ No newline at end of file"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"3adcfad0-68cc-4671-8328-85d5e3e6d6c9","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01ApehcTbFGZyJMpyUqjeSQ7","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Perfect! Now I need to finish fixing the remaining malformed section. Let me fix the last part:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":11214,"cache_read_input_tokens":48898,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS1NK9pXcpCaKcaGX6RCU","type":"assistant","uuid":"a8b418be-a0a8-4a9a-b4cb-536c49954807","timestamp":"2025-08-11T05:26:59.867Z"}
{"parentUuid":"a8b418be-a0a8-4a9a-b4cb-536c49954807","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01ApehcTbFGZyJMpyUqjeSQ7","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01NWxiwZszmUo5SkMhMKhG62","name":"Edit","input":{"file_path":"/Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md","old_string":"    printf(\"✓ Sprite rendering performance test passed\\n\");\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","new_string":"    printf(\"✓ Sprite rendering performance test passed\\n\");\n}\n```\n\n## Integration Points\n\n### Phase 3 Integration (GameObject & Transform)\n- Sprite component uses TransformComponent for world position and scale\n- Transform changes trigger sprite render cache updates\n- Anchor point calculations relative to transform\n\n### Phase 4 Integration (Scene Management)\n- Scene manages sprite component batches through component systems\n- Batch rendering coordinated by scene render system\n- Layer-based rendering order within scenes\n\n### Phase 5 Integration (Spatial Partitioning)\n- Frustum culling using spatial queries\n- Visibility determination for sprites\n- Performance optimization for large sprite counts\n\n## Performance Targets\n\n### Sprite Operations\n- **Sprite updates**: < 10μs per animated sprite\n- **Batch rendering**: 1000+ sprites at 30 FPS\n- **Memory overhead**: < 5% for sprite management\n- **Animation processing**: < 1ms for 100 animated sprites\n\n### Rendering Efficiency\n- **Draw call batching**: Minimize Playdate graphics calls\n- **Frustum culling**: Skip off-screen sprites\n- **Layer sorting**: Efficient depth-based rendering\n- **Atlas optimization**: Shared texture usage\n\n## Testing Criteria\n\n### Unit Test Requirements\n- ✅ Sprite component creation and destruction\n- ✅ Bitmap loading and management\n- ✅ Source rectangle and sprite sheet support\n- ✅ Animation system functionality\n- ✅ Rendering property management\n- ✅ Visibility and culling behavior\n\n### Performance Test Requirements\n- ✅ Sprite update speed benchmarks\n- ✅ Batch rendering performance\n- ✅ Animation processing efficiency\n- ✅ Memory usage measurements\n\n### Integration Test Requirements\n- ✅ Transform component integration\n- ✅ Scene management coordination\n- ✅ Spatial partitioning integration\n- ✅ Playdate SDK graphics integration\n\n## Success Criteria\n\n### Functional Requirements\n- [ ] Sprite component with full Playdate graphics integration\n- [ ] Sprite sheet and animation support\n- [ ] Batch rendering system for performance\n- [ ] Frustum culling and visibility management\n- [ ] Layer-based rendering with depth sorting\n\n### Performance Requirements\n- [ ] 1000+ sprites rendered at 30 FPS\n- [ ] < 10μs animation updates per sprite\n- [ ] Efficient batch rendering with minimal draw calls\n- [ ] < 5% memory overhead for sprite management\n\n### Quality Requirements\n- [ ] 100% unit test coverage for sprite system\n- [ ] Performance benchmarks meet all targets\n- [ ] Clean integration with transform and scene systems\n- [ ] Robust error handling and resource management\n\n## Next Steps\n\nUpon completion of this phase:\n1. Verify all sprite component tests pass\n2. Confirm performance benchmarks meet targets\n3. Test integration with Playdate SDK graphics\n4. Proceed to Phase 7: Collision Component implementation\n5. Begin implementing collision detection with sprite bounds\n\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":11214,"cache_read_input_tokens":48898,"output_tokens":1665,"service_tier":"standard"}},"requestId":"req_011CS1NK9pXcpCaKcaGX6RCU","type":"assistant","uuid":"992375b9-db2d-4364-90b0-206f971d71f8","timestamp":"2025-08-11T05:27:12.621Z"}
{"parentUuid":"992375b9-db2d-4364-90b0-206f971d71f8","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NWxiwZszmUo5SkMhMKhG62","type":"tool_result","content":"The file /Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   797→    \n   798→    sprite_renderer_destroy(renderer);\n   799→    mock_scene_destroy(scene);\n   800→    component_registry_shutdown();\n   801→    printf(\"✓ Sprite rendering performance test passed\\n\");\n   802→}\n   803→```\n   804→\n   805→## Integration Points\n   806→\n   807→### Phase 3 Integration (GameObject & Transform)\n   808→- Sprite component uses TransformComponent for world position and scale\n   809→- Transform changes trigger sprite render cache updates\n   810→- Anchor point calculations relative to transform\n   811→\n   812→### Phase 4 Integration (Scene Management)\n   813→- Scene manages sprite component batches through component systems\n   814→- Batch rendering coordinated by scene render system\n   815→- Layer-based rendering order within scenes\n   816→\n   817→### Phase 5 Integration (Spatial Partitioning)\n   818→- Frustum culling using spatial queries\n   819→- Visibility determination for sprites\n   820→- Performance optimization for large sprite counts\n   821→\n   822→## Performance Targets\n   823→\n   824→### Sprite Operations\n   825→- **Sprite updates**: < 10μs per animated sprite\n   826→- **Batch rendering**: 1000+ sprites at 30 FPS\n   827→- **Memory overhead**: < 5% for sprite management\n   828→- **Animation processing**: < 1ms for 100 animated sprites\n   829→\n   830→### Rendering Efficiency\n   831→- **Draw call batching**: Minimize Playdate graphics calls\n   832→- **Frustum culling**: Skip off-screen sprites\n   833→- **Layer sorting**: Efficient depth-based rendering\n   834→- **Atlas optimization**: Shared texture usage\n   835→\n   836→## Testing Criteria\n   837→\n   838→### Unit Test Requirements\n   839→- ✅ Sprite component creation and destruction\n   840→- ✅ Bitmap loading and management\n   841→- ✅ Source rectangle and sprite sheet support\n   842→- ✅ Animation system functionality\n   843→- ✅ Rendering property management\n   844→- ✅ Visibility and culling behavior\n   845→\n   846→### Performance Test Requirements\n   847→- ✅ Sprite update speed benchmarks\n   848→- ✅ Batch rendering performance\n   849→- ✅ Animation processing efficiency\n   850→- ✅ Memory usage measurements\n   851→\n   852→### Integration Test Requirements\n   853→- ✅ Transform component integration\n   854→- ✅ Scene management coordination\n   855→- ✅ Spatial partitioning integration\n   856→- ✅ Playdate SDK graphics integration\n   857→\n   858→## Success Criteria\n   859→\n   860→### Functional Requirements\n   861→- [ ] Sprite component with full Playdate graphics integration\n   862→- [ ] Sprite sheet and animation support\n   863→- [ ] Batch rendering system for performance\n   864→- [ ] Frustum culling and visibility management\n   865→- [ ] Layer-based rendering with depth sorting\n   866→\n   867→### Performance Requirements\n   868→- [ ] 1000+ sprites rendered at 30 FPS\n   869→- [ ] < 10μs animation updates per sprite\n   870→- [ ] Efficient batch rendering with minimal draw calls\n   871→- [ ] < 5% memory overhead for sprite management\n   872→\n   873→### Quality Requirements\n   874→- [ ] 100% unit test coverage for sprite system\n   875→- [ ] Performance benchmarks meet all targets\n   876→- [ ] Clean integration with transform and scene systems\n   877→- [ ] Robust error handling and resource management\n   878→\n   879→## Next Steps\n   880→\n   881→Upon completion of this phase:\n   882→1. Verify all sprite component tests pass\n   883→2. Confirm performance benchmarks meet targets\n   884→3. Test integration with Playdate SDK graphics\n   885→4. Proceed to Phase 7: Collision Component implementation\n   886→5. Begin implementing collision detection with sprite bounds\n   887→\n   888→This phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform."}]},"uuid":"18019a8b-f762-4356-a5ea-fc4c2838a7e3","timestamp":"2025-08-11T05:27:12.689Z","toolUseResult":{"filePath":"/Users/matheusmortatti/git/playdate-engine/tasks/phase-6-sprite-component.md","oldString":"    printf(\"✓ Sprite rendering performance test passed\\n\");\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","newString":"    printf(\"✓ Sprite rendering performance test passed\\n\");\n}\n```\n\n## Integration Points\n\n### Phase 3 Integration (GameObject & Transform)\n- Sprite component uses TransformComponent for world position and scale\n- Transform changes trigger sprite render cache updates\n- Anchor point calculations relative to transform\n\n### Phase 4 Integration (Scene Management)\n- Scene manages sprite component batches through component systems\n- Batch rendering coordinated by scene render system\n- Layer-based rendering order within scenes\n\n### Phase 5 Integration (Spatial Partitioning)\n- Frustum culling using spatial queries\n- Visibility determination for sprites\n- Performance optimization for large sprite counts\n\n## Performance Targets\n\n### Sprite Operations\n- **Sprite updates**: < 10μs per animated sprite\n- **Batch rendering**: 1000+ sprites at 30 FPS\n- **Memory overhead**: < 5% for sprite management\n- **Animation processing**: < 1ms for 100 animated sprites\n\n### Rendering Efficiency\n- **Draw call batching**: Minimize Playdate graphics calls\n- **Frustum culling**: Skip off-screen sprites\n- **Layer sorting**: Efficient depth-based rendering\n- **Atlas optimization**: Shared texture usage\n\n## Testing Criteria\n\n### Unit Test Requirements\n- ✅ Sprite component creation and destruction\n- ✅ Bitmap loading and management\n- ✅ Source rectangle and sprite sheet support\n- ✅ Animation system functionality\n- ✅ Rendering property management\n- ✅ Visibility and culling behavior\n\n### Performance Test Requirements\n- ✅ Sprite update speed benchmarks\n- ✅ Batch rendering performance\n- ✅ Animation processing efficiency\n- ✅ Memory usage measurements\n\n### Integration Test Requirements\n- ✅ Transform component integration\n- ✅ Scene management coordination\n- ✅ Spatial partitioning integration\n- ✅ Playdate SDK graphics integration\n\n## Success Criteria\n\n### Functional Requirements\n- [ ] Sprite component with full Playdate graphics integration\n- [ ] Sprite sheet and animation support\n- [ ] Batch rendering system for performance\n- [ ] Frustum culling and visibility management\n- [ ] Layer-based rendering with depth sorting\n\n### Performance Requirements\n- [ ] 1000+ sprites rendered at 30 FPS\n- [ ] < 10μs animation updates per sprite\n- [ ] Efficient batch rendering with minimal draw calls\n- [ ] < 5% memory overhead for sprite management\n\n### Quality Requirements\n- [ ] 100% unit test coverage for sprite system\n- [ ] Performance benchmarks meet all targets\n- [ ] Clean integration with transform and scene systems\n- [ ] Robust error handling and resource management\n\n## Next Steps\n\nUpon completion of this phase:\n1. Verify all sprite component tests pass\n2. Confirm performance benchmarks meet targets\n3. Test integration with Playdate SDK graphics\n4. Proceed to Phase 7: Collision Component implementation\n5. Begin implementing collision detection with sprite bounds\n\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","originalFile":"# Phase 6: Sprite Component\n\n## Objective\n\nImplement a high-performance sprite rendering system with Playdate SDK integration, supporting batch rendering, sprite sheets, animations, and visual effects. This component targets 1000+ sprites per frame with hardware-accelerated rendering and memory-efficient asset management.\n\n## Prerequisites\n\n- **Phase 1**: Memory Management (ObjectPool system)\n- **Phase 2**: Component System (Component architecture)\n- **Phase 3**: GameObject & Transform (Core entities)\n- **Phase 4**: Scene Management (Scene organization)\n- **Phase 5**: Spatial Partitioning (Spatial optimization)\n- Playdate SDK graphics API knowledge\n- Understanding of sprite rendering optimization\n\n## Technical Specifications\n\n### Performance Targets\n- **Sprite rendering**: 1000+ sprites per frame at 30 FPS\n- **Batch rendering**: Minimize draw calls through sprite batching\n- **Memory efficiency**: < 5% overhead for sprite management\n- **Animation updates**: < 10µs per animated sprite\n- **Visibility culling**: Spatial query integration for off-screen culling\n\n### Sprite System Architecture Goals\n- **Playdate integration**: Native LCDBitmap and rendering API usage\n- **Sprite sheet support**: Efficient sub-rectangle rendering\n- **Animation system**: Frame-based and timeline animations\n- **Layering system**: Z-depth sorting and render order\n- **Visual effects**: Alpha, scaling, rotation, color effects\n\n## Code Structure\n\n```\nsrc/components/\n├── sprite_component.h      # Sprite component interface\n├── sprite_component.c      # Sprite implementation\n├── sprite_renderer.h       # Batch rendering system\n├── sprite_renderer.c       # Renderer implementation\n├── sprite_animation.h      # Animation system\n└── sprite_animation.c      # Animation implementation\n\nsrc/assets/\n├── sprite_loader.h         # Asset loading utilities\n├── sprite_loader.c         # Loader implementation\n├── sprite_atlas.h          # Sprite sheet management\n└── sprite_atlas.c          # Atlas implementation\n\ntests/components/\n├── test_sprite_component.c # Sprite component tests\n├── test_sprite_renderer.c  # Renderer tests\n├── test_sprite_animation.c # Animation tests\n└── test_sprite_perf.c      # Performance benchmarks\n\nexamples/\n├── sprite_demo.c           # Basic sprite usage\n├── animation_demo.c        # Animation examples\n└── batch_rendering.c       # Performance optimization demo\n```\n\n## Implementation Steps\n\n### Step 1: Sprite Component Core Structure\n\n```c\n// sprite_component.h\n#ifndef SPRITE_COMPONENT_H\n#define SPRITE_COMPONENT_H\n\n#include \"component.h\"\n#include \"pd_api.h\"\n#include <stdint.h>\n#include <stdbool.h>\n\n// Forward declarations\ntypedef struct SpriteComponent SpriteComponent;\ntypedef struct SpriteAnimation SpriteAnimation;\ntypedef struct SpriteAtlas SpriteAtlas;\n\n// Sprite rendering modes\ntypedef enum {\n    SPRITE_RENDER_NORMAL = 0,\n    SPRITE_RENDER_ADDITIVE,\n    SPRITE_RENDER_MULTIPLY,\n    SPRITE_RENDER_SUBTRACT,\n    SPRITE_RENDER_MASK\n} SpriteRenderMode;\n\n// Sprite component structure (128 bytes target)\ntypedef struct SpriteComponent {\n    Component base;                    // 32 bytes - base component\n    \n    // Rendering properties\n    LCDBitmap* bitmap;                // 8 bytes - Playdate bitmap\n    LCDRect sourceRect;               // 16 bytes - Source rectangle {x, y, width, height}\n    float anchorX, anchorY;           // 8 bytes - Anchor point (0.0-1.0)\n    LCDBitmapFlip flip;               // 4 bytes - Horizontal/vertical flip\n    float opacity;                    // 4 bytes - Alpha value (0.0-1.0)\n    SpriteRenderMode renderMode;      // 4 bytes - Blend mode\n    \n    // Transform cache (for performance)\n    float renderX, renderY;           // 8 bytes - Cached render position\n    float renderWidth, renderHeight;  // 8 bytes - Cached render size\n    bool transformDirty;              // 1 byte - Needs position recalculation\n    \n    // Animation system\n    SpriteAnimation* animation;       // 8 bytes - Current animation\n    float animationTime;              // 4 bytes - Current animation time\n    uint32_t currentFrame;            // 4 bytes - Current frame index\n    bool animationPlaying;            // 1 byte - Animation state\n    bool animationLooping;            // 1 byte - Loop flag\n    \n    // Sprite sheet support\n    SpriteAtlas* atlas;               // 8 bytes - Sprite atlas reference\n    uint32_t atlasIndex;              // 4 bytes - Index in atlas\n    \n    // Rendering optimization\n    bool visible;                     // 1 byte - Visibility flag\n    bool culled;                      // 1 byte - Frustum culled\n    uint32_t renderLayer;             // 4 bytes - Z-depth layer\n    uint32_t sortingOrder;            // 4 bytes - Order within layer\n    \n    // Color and effects\n    uint8_t colorR, colorG, colorB;   // 3 bytes - Color tint (0-255)\n    uint8_t padding[9];               // 9 bytes - Explicit padding to 128 bytes\n    \n} SpriteComponent;\n\n// Sprite animation frame\ntypedef struct SpriteFrame {\n    LCDRect sourceRect;               // Source rectangle in sprite sheet\n    float duration;                   // Frame duration in seconds\n    float anchorX, anchorY;           // Frame-specific anchor point\n} SpriteFrame;\n\n// Sprite animation\ntypedef struct SpriteAnimation {\n    char name[32];                    // Animation name\n    SpriteFrame* frames;              // Array of animation frames\n    uint32_t frameCount;              // Number of frames\n    float totalDuration;              // Total animation duration\n    bool looping;                     // Default looping behavior\n    SpriteAnimation* nextAnimation;   // Animation to play after this one\n} SpriteAnimation;\n\n// Sprite component interface\nSpriteComponent* sprite_component_create(GameObject* gameObject);\nvoid sprite_component_destroy(SpriteComponent* sprite);\n\n// Bitmap management\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap);\nLCDBitmap* sprite_component_get_bitmap(SpriteComponent* sprite);\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path);\n\n// Source rectangle (for sprite sheets)\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height);\nLCDRect sprite_component_get_source_rect(SpriteComponent* sprite);\n\n// Rendering properties\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY);\nvoid sprite_component_get_anchor(SpriteComponent* sprite, float* anchorX, float* anchorY);\nvoid sprite_component_set_flip(SpriteComponent* sprite, LCDBitmapFlip flip);\nLCDBitmapFlip sprite_component_get_flip(SpriteComponent* sprite);\nvoid sprite_component_set_opacity(SpriteComponent* sprite, float opacity);\nfloat sprite_component_get_opacity(SpriteComponent* sprite);\n\n// Animation control\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation);\nvoid sprite_component_stop_animation(SpriteComponent* sprite);\nvoid sprite_component_pause_animation(SpriteComponent* sprite);\nvoid sprite_component_resume_animation(SpriteComponent* sprite);\nbool sprite_component_is_animation_playing(SpriteComponent* sprite);\n\n// Visibility and culling\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible);\nbool sprite_component_is_visible(SpriteComponent* sprite);\nvoid sprite_component_set_render_layer(SpriteComponent* sprite, uint32_t layer);\nuint32_t sprite_component_get_render_layer(SpriteComponent* sprite);\n\n// Color and effects\nvoid sprite_component_set_color(SpriteComponent* sprite, uint8_t r, uint8_t g, uint8_t b);\nvoid sprite_component_get_color(SpriteComponent* sprite, uint8_t* r, uint8_t* g, uint8_t* b);\n\n// Atlas support\nbool sprite_component_set_atlas(SpriteComponent* sprite, SpriteAtlas* atlas, uint32_t index);\n\n// Component system integration\nvoid sprite_component_register(void);\n\n// Fast access helpers\nstatic inline bool sprite_component_needs_render(SpriteComponent* sprite) {\n    return sprite && sprite->visible && !sprite->culled && sprite->bitmap && sprite->opacity > 0.0f;\n}\n\nstatic inline void sprite_component_mark_transform_dirty(SpriteComponent* sprite) {\n    if (sprite) sprite->transformDirty = true;\n}\n\n#endif // SPRITE_COMPONENT_H\n```\n\n### Step 2: Sprite Component Implementation\n\n```c\n// sprite_component.c\n#include \"sprite_component.h\"\n#include \"component_registry.h\"\n#include \"game_object.h\"\n#include \"transform_component.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n// Sprite component vtable\nstatic void sprite_component_init(Component* component, GameObject* gameObject);\nstatic void sprite_component_destroy_impl(Component* component);\nstatic void sprite_component_update(Component* component, float deltaTime);\nstatic void sprite_component_render(Component* component);\n\nstatic const ComponentVTable spriteVTable = {\n    .init = sprite_component_init,\n    .destroy = sprite_component_destroy_impl,\n    .update = sprite_component_update,\n    .render = sprite_component_render,\n    .clone = NULL,\n    .fixedUpdate = NULL,\n    .onEnabled = NULL,\n    .onDisabled = NULL,\n    .onGameObjectDestroyed = NULL,\n    .getSerializedSize = NULL,\n    .serialize = NULL,\n    .deserialize = NULL\n};\n\n// Global Playdate API reference\nstatic PlaydateAPI* g_pd = NULL;\n\nvoid sprite_component_register(void) {\n    component_registry_register_type(\n        COMPONENT_TYPE_SPRITE,\n        sizeof(SpriteComponent),\n        1000, // Pool size\n        &spriteVTable,\n        \"Sprite\"\n    );\n}\n\nvoid sprite_component_set_playdate_api(PlaydateAPI* pd) {\n    g_pd = pd;\n}\n\nSpriteComponent* sprite_component_create(GameObject* gameObject) {\n    Component* baseComponent = component_registry_create(COMPONENT_TYPE_SPRITE, gameObject);\n    return (SpriteComponent*)baseComponent;\n}\n\nstatic void sprite_component_init(Component* component, GameObject* gameObject) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Initialize sprite properties\n    sprite->bitmap = NULL;\n    sprite->sourceRect = (LCDRect){0, 0, 0, 0};\n    sprite->anchorX = 0.5f;\n    sprite->anchorY = 0.5f;\n    sprite->flip = kBitmapUnflipped;\n    sprite->opacity = 1.0f;\n    sprite->renderMode = SPRITE_RENDER_NORMAL;\n    \n    // Initialize cached transform\n    sprite->renderX = 0.0f;\n    sprite->renderY = 0.0f;\n    sprite->renderWidth = 0.0f;\n    sprite->renderHeight = 0.0f;\n    sprite->transformDirty = true;\n    \n    // Initialize animation\n    sprite->animation = NULL;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = false;\n    sprite->animationLooping = false;\n    \n    // Initialize atlas\n    sprite->atlas = NULL;\n    sprite->atlasIndex = 0;\n    \n    // Initialize rendering\n    sprite->visible = true;\n    sprite->culled = false;\n    sprite->renderLayer = 0;\n    sprite->sortingOrder = 0;\n    \n    // Initialize color\n    sprite->colorR = 255;\n    sprite->colorG = 255;\n    sprite->colorB = 255;\n}\n\nstatic void sprite_component_destroy_impl(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    // Note: We don't free the bitmap here as it may be shared\n    // Bitmap management should be handled by asset management system\n    sprite->bitmap = NULL;\n    sprite->animation = NULL;\n    sprite->atlas = NULL;\n}\n\nstatic void sprite_component_update(Component* component, float deltaTime) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite->visible) {\n        return;\n    }\n    \n    // Update animation\n    if (sprite->animationPlaying && sprite->animation) {\n        sprite->animationTime += deltaTime;\n        \n        // Check if animation finished\n        if (sprite->animationTime >= sprite->animation->totalDuration) {\n            if (sprite->animationLooping || sprite->animation->looping) {\n                sprite->animationTime = fmodf(sprite->animationTime, sprite->animation->totalDuration);\n            } else {\n                sprite->animationTime = sprite->animation->totalDuration;\n                sprite->animationPlaying = false;\n                \n                // Play next animation if specified\n                if (sprite->animation->nextAnimation) {\n                    sprite_component_play_animation(sprite, sprite->animation->nextAnimation);\n                }\n            }\n        }\n        \n        // Update current frame\n        sprite_component_update_animation_frame(sprite);\n    }\n    \n    // Update transform cache if dirty\n    if (sprite->transformDirty) {\n        sprite_component_update_transform_cache(sprite);\n    }\n}\n\nstatic void sprite_component_render(Component* component) {\n    SpriteComponent* sprite = (SpriteComponent*)component;\n    \n    if (!sprite_component_needs_render(sprite) || !g_pd) {\n        return;\n    }\n    \n    // Set rendering properties\n    if (sprite->opacity < 1.0f) {\n        // Handle transparency (Playdate is 1-bit, so this might be dithering)\n        // Implementation depends on Playdate's capabilities\n    }\n    \n    // Calculate render position with anchor\n    float renderX = sprite->renderX - (sprite->renderWidth * sprite->anchorX);\n    float renderY = sprite->renderY - (sprite->renderHeight * sprite->anchorY);\n    \n    // Render sprite\n    if (sprite->sourceRect.width > 0 && sprite->sourceRect.height > 0) {\n        // Render with source rectangle (sprite sheet)\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    } else {\n        // Render full bitmap\n        g_pd->graphics->drawBitmap(sprite->bitmap, \n                                 (int)renderX, (int)renderY, \n                                 sprite->flip);\n    }\n}\n\nbool sprite_component_set_bitmap(SpriteComponent* sprite, LCDBitmap* bitmap) {\n    if (!sprite) {\n        return false;\n    }\n    \n    sprite->bitmap = bitmap;\n    \n    if (bitmap && g_pd) {\n        // Update source rectangle to match bitmap size if not set\n        if (sprite->sourceRect.width == 0 || sprite->sourceRect.height == 0) {\n            int width, height;\n            g_pd->graphics->getBitmapData(bitmap, &width, &height, NULL, NULL, NULL);\n            sprite->sourceRect = (LCDRect){0, 0, width, height};\n        }\n        \n        sprite_component_mark_transform_dirty(sprite);\n    }\n    \n    return true;\n}\n\nbool sprite_component_load_bitmap(SpriteComponent* sprite, const char* path) {\n    if (!sprite || !path || !g_pd) {\n        return false;\n    }\n    \n    LCDBitmap* bitmap = g_pd->graphics->loadBitmap(path, NULL);\n    if (!bitmap) {\n        return false;\n    }\n    \n    return sprite_component_set_bitmap(sprite, bitmap);\n}\n\nvoid sprite_component_set_source_rect(SpriteComponent* sprite, int x, int y, int width, int height) {\n    if (!sprite) return;\n    \n    sprite->sourceRect = (LCDRect){x, y, width, height};\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nvoid sprite_component_set_anchor(SpriteComponent* sprite, float anchorX, float anchorY) {\n    if (!sprite) return;\n    \n    sprite->anchorX = anchorX;\n    sprite->anchorY = anchorY;\n    sprite_component_mark_transform_dirty(sprite);\n}\n\nbool sprite_component_play_animation(SpriteComponent* sprite, SpriteAnimation* animation) {\n    if (!sprite || !animation) {\n        return false;\n    }\n    \n    sprite->animation = animation;\n    sprite->animationTime = 0.0f;\n    sprite->currentFrame = 0;\n    sprite->animationPlaying = true;\n    sprite->animationLooping = animation->looping;\n    \n    // Set first frame\n    if (animation->frameCount > 0) {\n        SpriteFrame* frame = &animation->frames[0];\n        sprite_component_set_source_rect(sprite, \n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n    \n    return true;\n}\n\nvoid sprite_component_set_visible(SpriteComponent* sprite, bool visible) {\n    if (sprite) {\n        sprite->visible = visible;\n    }\n}\n\n// Helper function to update animation frame\nstatic void sprite_component_update_animation_frame(SpriteComponent* sprite) {\n    if (!sprite->animation || sprite->animation->frameCount == 0) {\n        return;\n    }\n    \n    // Find current frame based on time\n    float accumulatedTime = 0.0f;\n    uint32_t frameIndex = 0;\n    \n    for (uint32_t i = 0; i < sprite->animation->frameCount; i++) {\n        accumulatedTime += sprite->animation->frames[i].duration;\n        if (sprite->animationTime < accumulatedTime) {\n            frameIndex = i;\n            break;\n        }\n    }\n    \n    // Update frame if changed\n    if (frameIndex != sprite->currentFrame) {\n        sprite->currentFrame = frameIndex;\n        SpriteFrame* frame = &sprite->animation->frames[frameIndex];\n        \n        sprite_component_set_source_rect(sprite,\n                                        frame->sourceRect.x, frame->sourceRect.y,\n                                        frame->sourceRect.width, frame->sourceRect.height);\n        sprite_component_set_anchor(sprite, frame->anchorX, frame->anchorY);\n    }\n}\n\n// Helper function to update transform cache\nstatic void sprite_component_update_transform_cache(SpriteComponent* sprite) {\n    if (!sprite || !sprite->base.gameObject || !sprite->base.gameObject->transform) {\n        return;\n    }\n    \n    TransformComponent* transform = sprite->base.gameObject->transform;\n    \n    // Get world position\n    transform_component_get_position(transform, &sprite->renderX, &sprite->renderY);\n    \n    // Get render size\n    sprite->renderWidth = (float)sprite->sourceRect.width;\n    sprite->renderHeight = (float)sprite->sourceRect.height;\n    \n    // Apply transform scale\n    float scaleX, scaleY;\n    transform_component_get_scale(transform, &scaleX, &scaleY);\n    sprite->renderWidth *= scaleX;\n    sprite->renderHeight *= scaleY;\n    \n    sprite->transformDirty = false;\n}\n```\n\n### Step 3: Sprite Renderer (Batch System)\n\n```c\n// sprite_renderer.h\n#ifndef SPRITE_RENDERER_H\n#define SPRITE_RENDERER_H\n\n#include \"sprite_component.h\"\n#include \"spatial_grid.h\"\n#include \"pd_api.h\"\n\n#define MAX_SPRITES_PER_BATCH 256\n#define MAX_RENDER_LAYERS 16\n\n// Sprite batch for efficient rendering\ntypedef struct SpriteBatch {\n    SpriteComponent** sprites;     // Array of sprites to render\n    uint32_t spriteCount;         // Number of sprites in batch\n    uint32_t capacity;            // Maximum sprites in batch\n    uint32_t renderLayer;         // Layer this batch renders\n    LCDBitmap* sharedBitmap;      // Shared bitmap for batching optimization\n} SpriteBatch;\n\n// Sprite renderer system\ntypedef struct SpriteRenderer {\n    SpriteBatch batches[MAX_RENDER_LAYERS]; // One batch per layer\n    uint32_t activeBatches;                 // Number of active batches\n    \n    // Culling support\n    SpatialGrid* spatialGrid;               // For frustum culling\n    LCDRect viewportRect;                   // Camera viewport\n    bool frustumCullingEnabled;\n    \n    // Performance statistics\n    uint32_t spritesRendered;\n    uint32_t spritesculled;\n    uint32_t drawCalls;\n    float lastRenderTime;\n    \n    // Playdate API reference\n    PlaydateAPI* pd;\n    \n} SpriteRenderer;\n\n// Renderer management\nSpriteRenderer* sprite_renderer_create(PlaydateAPI* pd, SpatialGrid* spatialGrid);\nvoid sprite_renderer_destroy(SpriteRenderer* renderer);\n\n// Rendering operations\nvoid sprite_renderer_begin_frame(SpriteRenderer* renderer);\nvoid sprite_renderer_render_sprites(SpriteRenderer* renderer, SpriteComponent** sprites, uint32_t count);\nvoid sprite_renderer_end_frame(SpriteRenderer* renderer);\n\n// Viewport and culling\nvoid sprite_renderer_set_viewport(SpriteRenderer* renderer, int x, int y, int width, int height);\nvoid sprite_renderer_enable_frustum_culling(SpriteRenderer* renderer, bool enabled);\n\n// Performance and debugging\nvoid sprite_renderer_print_stats(SpriteRenderer* renderer);\nvoid sprite_renderer_reset_stats(SpriteRenderer* renderer);\n\n#endif // SPRITE_RENDERER_H\n```\n\n## Unit Tests\n\n### Sprite Component Tests\n\n```c\n// tests/components/test_sprite_component.c\n#include \"sprite_component.h\"\n#include \"game_object.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// Mock Playdate API for testing\nstatic LCDBitmap* mock_bitmap = (LCDBitmap*)0x12345678;\n\nvoid test_sprite_component_creation(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    \n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    assert(sprite != NULL);\n    assert(sprite->base.type == COMPONENT_TYPE_SPRITE);\n    assert(sprite->visible == true);\n    assert(sprite->opacity == 1.0f);\n    assert(sprite->anchorX == 0.5f && sprite->anchorY == 0.5f);\n    assert(sprite->renderLayer == 0);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite component creation test passed\\n\");\n}\n\nvoid test_sprite_bitmap_management(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Test bitmap setting\n    bool result = sprite_component_set_bitmap(sprite, mock_bitmap);\n    assert(result == true);\n    assert(sprite_component_get_bitmap(sprite) == mock_bitmap);\n    \n    // Test source rectangle\n    sprite_component_set_source_rect(sprite, 10, 20, 64, 48);\n    LCDRect rect = sprite_component_get_source_rect(sprite);\n    assert(rect.x == 10 && rect.y == 20);\n    assert(rect.width == 64 && rect.height == 48);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite bitmap management test passed\\n\");\n}\n\nvoid test_sprite_rendering_properties(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Test anchor\n    sprite_component_set_anchor(sprite, 0.0f, 1.0f);\n    float anchorX, anchorY;\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\n    assert(anchorX == 0.0f && anchorY == 1.0f);\n    \n    // Test opacity\n    sprite_component_set_opacity(sprite, 0.5f);\n    assert(sprite_component_get_opacity(sprite) == 0.5f);\n    \n    // Test visibility\n    sprite_component_set_visible(sprite, false);\n    assert(sprite_component_is_visible(sprite) == false);\n    \n    // Test render layer\n    sprite_component_set_render_layer(sprite, 5);\n    assert(sprite_component_get_render_layer(sprite) == 5);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite rendering properties test passed\\n\");\n}\n\nvoid test_sprite_animation_system(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    GameObject* gameObject = game_object_create(scene);\n    SpriteComponent* sprite = sprite_component_create(gameObject);\n    \n    // Create test animation\n    SpriteAnimation animation;\n    strcpy(animation.name, \"test_anim\");\n    animation.frameCount = 3;\n    animation.looping = true;\n    animation.nextAnimation = NULL;\n    \n    SpriteFrame frames[3] = {\n        {{0, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n        {{32, 0, 32, 32}, 0.1f, 0.5f, 0.5f},\n        {{64, 0, 32, 32}, 0.1f, 0.5f, 0.5f}\n    };\n    animation.frames = frames;\n    animation.totalDuration = 0.3f;\n    \n    // Test animation playback\n    bool result = sprite_component_play_animation(sprite, &animation);\n    assert(result == true);\n    assert(sprite_component_is_animation_playing(sprite) == true);\n    assert(sprite->currentFrame == 0);\n    \n    // Simulate time progression\n    Component* baseComponent = (Component*)sprite;\n    sprite_component_update(baseComponent, 0.15f); // Should advance to frame 1\n    assert(sprite->currentFrame == 1);\n    \n    sprite_component_stop_animation(sprite);\n    assert(sprite_component_is_animation_playing(sprite) == false);\n    \n    game_object_destroy(gameObject);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite animation system test passed\\n\");\n}\n```\n\n### Performance Tests\n\n```c\n// tests/components/test_sprite_perf.c\n#include \"sprite_component.h\"\n#include \"sprite_renderer.h\"\n#include <time.h>\n#include <stdio.h>\n\nvoid benchmark_sprite_updates(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = mock_scene_create();\n    SpriteComponent* sprites[1000];\n    \n    // Create many sprites\n    for (int i = 0; i < 1000; i++) {\n        GameObject* obj = game_object_create(scene);\n        sprites[i] = sprite_component_create(obj);\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n        sprite_component_set_source_rect(sprites[i], 0, 0, 32, 32);\n    }\n    \n    clock_t start = clock();\n    \n    // Update all sprites for 100 frames\n    for (int frame = 0; frame < 100; frame++) {\n        for (int i = 0; i < 1000; i++) {\n            Component* baseComponent = (Component*)sprites[i];\n            sprite_component_update(baseComponent, 0.016f);\n        }\n    }\n    \n    clock_t end = clock();\n    \n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n    double per_frame = time_taken / 100;\n    double per_sprite = (time_taken * 1000) / (100 * 1000); // microseconds per sprite\n    \n    printf(\"Sprite updates: %.2f ms per frame, %.2f μs per sprite\\n\", \n           per_frame, per_sprite);\n    \n    // Verify performance target\n    assert(per_sprite < 10); // Less than 10μs per sprite update\n    \n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite update performance test passed\\n\");\n}\n\nvoid benchmark_sprite_rendering(void) {\n    component_registry_init();\n    sprite_component_register();\n    \n    // Mock Playdate API setup would go here\n    SpriteRenderer* renderer = sprite_renderer_create(NULL, NULL);\n    \n    Scene* scene = mock_scene_create();\n    SpriteComponent* sprites[1000];\n    \n    // Create sprites\n    for (int i = 0; i < 1000; i++) {\n        GameObject* obj = game_object_create(scene);\n        sprites[i] = sprite_component_create(obj);\n        sprite_component_set_bitmap(sprites[i], mock_bitmap);\n        game_object_set_position(obj, i % 400, (i / 400) * 32);\n    }\n    \n    clock_t start = clock();\n    \n    // Render sprites for 60 frames\n    for (int frame = 0; frame < 60; frame++) {\n        sprite_renderer_begin_frame(renderer);\n        sprite_renderer_render_sprites(renderer, sprites, 1000);\n        sprite_renderer_end_frame(renderer);\n    }\n    \n    clock_t end = clock();\n    \n    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000; // milliseconds\n    double per_frame = time_taken / 60;\n    \n    printf(\"Sprite rendering: %.2f ms per frame (1000 sprites)\\n\", per_frame);\n    \n    // Verify performance target: 1000 sprites in < 33ms (30 FPS)\n    assert(per_frame < 33);\n    \n    sprite_renderer_destroy(renderer);\n    mock_scene_destroy(scene);\n    component_registry_shutdown();\n    printf(\"✓ Sprite rendering performance test passed\\n\");\n}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","structuredPatch":[{"oldStart":799,"oldLines":4,"newStart":799,"newLines":90,"lines":["     mock_scene_destroy(scene);","     component_registry_shutdown();","     printf(\"✓ Sprite rendering performance test passed\\n\");","-}\\n```\\n\\n## Integration Points\\n\\n### Phase 3 Integration (GameObject & Transform)\\n- Sprite component uses TransformComponent for world position and scale\\n- Transform changes trigger sprite render cache updates\\n- Anchor point calculations relative to transform\\n\\n### Phase 4 Integration (Scene Management)\\n- Scene manages sprite component batches through component systems\\n- Batch rendering coordinated by scene render system\\n- Layer-based rendering order within scenes\\n\\n### Phase 5 Integration (Spatial Partitioning)\\n- Frustum culling using spatial queries\\n- Visibility determination for sprites\\n- Performance optimization for large sprite counts\\n\\n## Performance Targets\\n\\n### Sprite Operations\\n- **Sprite updates**: < 10μs per animated sprite\\n- **Batch rendering**: 1000+ sprites at 30 FPS\\n- **Memory overhead**: < 5% for sprite management\\n- **Animation processing**: < 1ms for 100 animated sprites\\n\\n### Rendering Efficiency\\n- **Draw call batching**: Minimize Playdate graphics calls\\n- **Frustum culling**: Skip off-screen sprites\\n- **Layer sorting**: Efficient depth-based rendering\\n- **Atlas optimization**: Shared texture usage\\n\\n## Testing Criteria\\n\\n### Unit Test Requirements\\n- ✅ Sprite component creation and destruction\\n- ✅ Bitmap loading and management\\n- ✅ Source rectangle and sprite sheet support\\n- ✅ Animation system functionality\\n- ✅ Rendering property management\\n- ✅ Visibility and culling behavior\\n\\n### Performance Test Requirements\\n- ✅ Sprite update speed benchmarks\\n- ✅ Batch rendering performance\\n- ✅ Animation processing efficiency\\n- ✅ Memory usage measurements\\n\\n### Integration Test Requirements\\n- ✅ Transform component integration\\n- ✅ Scene management coordination\\n- ✅ Spatial partitioning integration\\n- ✅ Playdate SDK graphics integration\\n\\n## Success Criteria\\n\\n### Functional Requirements\\n- [ ] Sprite component with full Playdate graphics integration\\n- [ ] Sprite sheet and animation support\\n- [ ] Batch rendering system for performance\\n- [ ] Frustum culling and visibility management\\n- [ ] Layer-based rendering with depth sorting\\n\\n### Performance Requirements\\n- [ ] 1000+ sprites rendered at 30 FPS\\n- [ ] < 10μs animation updates per sprite\\n- [ ] Efficient batch rendering with minimal draw calls\\n- [ ] < 5% memory overhead for sprite management\\n\\n### Quality Requirements\\n- [ ] 100% unit test coverage for sprite system\\n- [ ] Performance benchmarks meet all targets\\n- [ ] Clean integration with transform and scene systems\\n- [ ] Robust error handling and resource management\\n\\n## Next Steps\\n\\nUpon completion of this phase:\\n1. Verify all sprite component tests pass\\n2. Confirm performance benchmarks meet targets\\n3. Test integration with Playdate SDK graphics\\n4. Proceed to Phase 7: Collision Component implementation\\n5. Begin implementing collision detection with sprite bounds\\n\\nThis phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","\\ No newline at end of file","+}","+```","+","+## Integration Points","+","+### Phase 3 Integration (GameObject & Transform)","+- Sprite component uses TransformComponent for world position and scale","+- Transform changes trigger sprite render cache updates","+- Anchor point calculations relative to transform","+","+### Phase 4 Integration (Scene Management)","+- Scene manages sprite component batches through component systems","+- Batch rendering coordinated by scene render system","+- Layer-based rendering order within scenes","+","+### Phase 5 Integration (Spatial Partitioning)","+- Frustum culling using spatial queries","+- Visibility determination for sprites","+- Performance optimization for large sprite counts","+","+## Performance Targets","+","+### Sprite Operations","+- **Sprite updates**: < 10μs per animated sprite","+- **Batch rendering**: 1000+ sprites at 30 FPS","+- **Memory overhead**: < 5% for sprite management","+- **Animation processing**: < 1ms for 100 animated sprites","+","+### Rendering Efficiency","+- **Draw call batching**: Minimize Playdate graphics calls","+- **Frustum culling**: Skip off-screen sprites","+- **Layer sorting**: Efficient depth-based rendering","+- **Atlas optimization**: Shared texture usage","+","+## Testing Criteria","+","+### Unit Test Requirements","+- ✅ Sprite component creation and destruction","+- ✅ Bitmap loading and management","+- ✅ Source rectangle and sprite sheet support","+- ✅ Animation system functionality","+- ✅ Rendering property management","+- ✅ Visibility and culling behavior","+","+### Performance Test Requirements","+- ✅ Sprite update speed benchmarks","+- ✅ Batch rendering performance","+- ✅ Animation processing efficiency","+- ✅ Memory usage measurements","+","+### Integration Test Requirements","+- ✅ Transform component integration","+- ✅ Scene management coordination","+- ✅ Spatial partitioning integration","+- ✅ Playdate SDK graphics integration","+","+## Success Criteria","+","+### Functional Requirements","+- [ ] Sprite component with full Playdate graphics integration","+- [ ] Sprite sheet and animation support","+- [ ] Batch rendering system for performance","+- [ ] Frustum culling and visibility management","+- [ ] Layer-based rendering with depth sorting","+","+### Performance Requirements","+- [ ] 1000+ sprites rendered at 30 FPS","+- [ ] < 10μs animation updates per sprite","+- [ ] Efficient batch rendering with minimal draw calls","+- [ ] < 5% memory overhead for sprite management","+","+### Quality Requirements","+- [ ] 100% unit test coverage for sprite system","+- [ ] Performance benchmarks meet all targets","+- [ ] Clean integration with transform and scene systems","+- [ ] Robust error handling and resource management","+","+## Next Steps","+","+Upon completion of this phase:","+1. Verify all sprite component tests pass","+2. Confirm performance benchmarks meet targets","+3. Test integration with Playdate SDK graphics","+4. Proceed to Phase 7: Collision Component implementation","+5. Begin implementing collision detection with sprite bounds","+","+This phase provides the visual foundation for the engine, enabling efficient sprite-based rendering with animation support optimized for the Playdate platform.","\\ No newline at end of file"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"18019a8b-f762-4356-a5ea-fc4c2838a7e3","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01AuZrUhw8P6CTG464ffSeu3","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01VFnUmJwmEQvtLQfd7Xj5tG","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Fix escaped newlines and malformed code blocks in sprite component documentation","status":"completed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":2769,"cache_read_input_tokens":60112,"output_tokens":83,"service_tier":"standard"}},"requestId":"req_011CS1NLRrDTME4uBv4qRcik","type":"assistant","uuid":"5613336f-a2ad-43f7-b641-f93a558f87f2","timestamp":"2025-08-11T05:27:16.404Z"}
{"parentUuid":"5613336f-a2ad-43f7-b641-f93a558f87f2","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VFnUmJwmEQvtLQfd7Xj5tG","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"4185a8e8-6391-4124-adc6-b87b081a4913","timestamp":"2025-08-11T05:27:16.457Z","toolUseResult":{"oldTodos":[{"content":"Fix escaped newlines and malformed code blocks in sprite component documentation","status":"in_progress","id":"1"}],"newTodos":[{"content":"Fix escaped newlines and malformed code blocks in sprite component documentation","status":"completed","id":"1"}]}}
{"parentUuid":"4185a8e8-6391-4124-adc6-b87b081a4913","isSidechain":false,"userType":"external","cwd":"/Users/matheusmortatti/git/playdate-engine","sessionId":"512b74be-d4a5-4ad1-b150-fca55a1c820c","version":"1.0.72","gitBranch":"main","message":{"id":"msg_01RvRXKeFWt28ai3NeDHjU2Q","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Perfect! I have successfully fixed all the formatting issues in the `@tasks/phase-6-sprite-component.md` file. Here's what was corrected:\n\n## Fixed Issues:\n\n1. **Escaped newlines**: Converted all `\\\\n` sequences to proper line breaks\n2. **Malformed code blocks**: Restored proper C code formatting with correct indentation and structure\n3. **Improved readability**: All the C implementation code is now properly formatted and readable\n4. **Preserved content**: Maintained all technical specifications and implementation details\n\n## Key Sections Fixed:\n\n- **Sprite Component Implementation** (lines 258-507): All C code properly formatted\n- **Sprite Renderer Header** (lines 512-571): Clean code block formatting \n- **Unit Tests** (lines 578-707): Proper test code structure\n- **Performance Tests** (lines 712-802): Benchmark code correctly formatted\n- **Documentation sections**: All markdown formatting preserved and cleaned up\n\nThe file now has clean, readable C code blocks with proper indentation, making the technical documentation much more accessible for developers implementing the sprite component system for the Playdate game engine."}],"stop_reason":"end_turn","stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":125,"cache_read_input_tokens":62881,"output_tokens":257,"service_tier":"standard"}},"requestId":"req_011CS1NLhmRksFMMbu9hdrfx","type":"assistant","uuid":"619bff51-924f-42de-b202-be2e8c217b68","timestamp":"2025-08-11T05:27:24.212Z"}
